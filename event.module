<?php
// $Id$ 

include(drupal_get_path('module', 'event') .'/event.theme');

/**
 * @defgroup event_core Core drupal hooks
 */

/**
 * Provides a link to the CSS stylesheet associated with this module.
 *
 * @ingroup event_core
 * @return a &lt;style&gt; tag that indicates what file browsers should import
 */
function event_html_head() {
  $output = '<script type="text/javascript" language="javascript" src="'. drupal_get_path('module', 'event') .'/event.js"></script>';
  return $output.'<style type="text/css">@import url('. drupal_get_path('module', 'event') .'/event.css);</style>';
}

/**
 * Provides the links that should be displayed when viewing events.
 *
 * @ingroup event_core
 * @param $type the type of link (for example, 'node', 'page', or 'system') being requested
 * @param $node the node that is requesting the link.  This is used in conjunction with $type to further determine
 *        what sort of link to display.
 * @param $main unused in this method.
 * @return an array of links, or an empty array if no links apply for the criteria passed to this method.
 */
function event_link($type, $node = NULL, $teaser = FALSE) {
  switch ($type) {
    case 'node':
      if (event_enabled_state($node->type) == 'all') {
        $links[] = l(t('calendar'), 'event/'. format_date($node->start, 'custom', 'Y/m/d'));
      }
      elseif (event_enabled_state($node->type) == 'solo') {
        $links[] = l(t('calendar'), 'event/'. format_date($node->start, 'custom', 'Y/m/d') .'/month/'. $node->type);
      }
      break;
    case 'event_month':
      if (user_access('access content')) {
        $links[] = l(t('week'), "event/$node->year/$node->month/$node->day/week/". $node->filter, array('title' => t('Week view')));
        $links[] = l(t('day'), "event/$node->year/$node->month/$node->day/day/". $node->filter, array('title' => t('Day view')));
        $links[] = l(t('table'), "event/$node->year/$node->month/$node->day/table/". $node->filter, array('title' => t('Table view')));
      }
      break;
    case 'event_week':
      if (user_access('access content')) {
        $links[] = l(t('month'), "event/$node->year/$node->month/$node->day/month/". $node->filter, array('title' => t('Month view')));
        $links[] = l(t('day'), "event/$node->year/$node->month/$node->day/day/". $node->filter, array('title' => t('Day view')));
        $links[] = l(t('table'), "event/$node->year/$node->month/$node->day/table/". $node->filter, array('title' => t('Table view')));
      }
      break;
    case 'event_day':
      if (user_access('access content')) {
        $links[] = l(t('month'), "event/$node->year/$node->month/$node->day/month/". $node->filter, array('title' => t('Month view')));
        $links[] = l(t('week'), "event/$node->year/$node->month/$node->day/week/". $node->filter, array('title' => t('Week view')));
        $links[] = l(t('table'), "event/$node->year/$node->month/$node->day/table/". $node->filter, array('title' => t('Table view')));
      }
      break;
    case 'event_table':
      if (user_access('access content')) {
        $links[] = l(t('month'), "event/$node->year/$node->month/$node->day/month/". $node->filter, array('title' => t('Month view')));
        $links[] = l(t('week'), "event/$node->year/$node->month/$node->day/week/". $node->filter, array('title' => t('Week view')));
        $links[] = l(t('day'), "event/$node->year/$node->month/$node->day/day/". $node->filter, array('title' => t('Day view')));
      }
      break;
  }
  return $links ? $links : array();
}

/**
 * Implementation of hook_menu()
 *
 * @ingroup event_core
 */
function event_menu($may_cache) {
  global $user;

  $items = array();
  if ($may_cache) {
    $items[] = array('path' => 'event',
                     'title' => t('events'),
                     'callback' => 'event_page',
                     'access' => user_access('access content'),
                     'type' => MENU_CALLBACK);
    $items[] = array('path' => 'event/additem',
                     'title' => t('add item to calendar'),
                     'callback' => 'event_add_item',
                     'access' => user_access('access content'),
                     'type' => MENU_CALLBACK);
    $items[] = array('path' => 'event/type',
                     'title' => t('filter by content type'),
                     'callback' => 'event_type',
                     'access' => user_access('access content'),
                     'type' => MENU_CALLBACK);
    $items[] = array('path' => 'event/term',
                     'title' => t('filter by taxonomy'),
                     'callback' => 'event_term',
                     'access' => user_access('access content'),
                     'type' => MENU_CALLBACK);
  }
  else {
    drupal_set_html_head(event_html_head());
  }
  return $items;
}

/**
 * Displays and allows an administrator to change the settings for this module.
 *
 * @ingroup event_core
 * @return the content for a settings page.
 */
function event_settings() {

  if (variable_get('configurable_timezones', 0)) {
    $group .= form_radios(t('Event timezone input'), 'event_timezone_input', variable_get('event_timezone_input', 'site'), array('site' => t('Use the sitewide timezone'), 'user' => t('Use the timezone of the user editing or creating the event'), 'input' => t('Allow users to set event timezones')), t('Events are saved with a timezone value. This setting allows you to determine how the timezone is determined when creating or editing an event.'));

    $group .= form_radios(t('Event timezone display'), 'event_timezone_display', variable_get('event_timezone_display', 'event'), array('event' => t("Use the event's timezone."), 'user' => t("Use the user's timezone.")), t("Events are saved with a timezone value. This setting allows you to determine if the event's timezone or the user's personal timezone setting is used to display the time for an event."));
  }
  else {
    if (variable_get('event_timezone_input', 'site') == 'user') {
      variable_set('event_timezone_input', 'site');
    }
    variable_set('event_timezone_display', 'event');

    $group .= form_radios(t('Event timezone input'), 'event_timezone_input', variable_get('event_timezone_input', 'site'), array('site' => t('Use the sitewide timezone'), 'user" disabled' => t('Use the timezone of the user editing or creating the event'), 'input' => t('Allow users to set event timezones')), t("Events are saved with a timezone value. This setting allows you to determine how the timezone is determined when creating or editing an event. You must have 'Configurable time zones' enabled in %url before you can enable user's timezones for this feature.", array('%url' => l(t('site configuration'), 'admin/settings'))));

    $group .= form_radios(t('Event timezone display'), 'event_timezone_display', 'event', array('event' => t("Use the event's timezone"), 'user' => t("Use the user's timezone")), t("Events are saved with a timezone value. This setting allows you to determine if the event's timezone or the user's personal timezone setting is used to display the time for an event. You must have 'Configurable time zones' enabled in %url before you can enable user's timezones for this feature.", array('%url' => l(t('site configuration'), 'admin/settings'))), '', array('disabled' => true));
  }
  $group .= form_radios(t('Time notation preference'), 'event_ampm', variable_get('event_ampm', '0'), array('0' => t('24h'),'1' => t('12h')), t('The time notation system used for entering event times.'));
  $output = form_group(t('General Event options'), $group);

  $group = form_radios(t('Default overview'), 'event_overview', variable_get('event_overview', 'day'), array('day' => t('Day'), 'week' => t('Week'), 'month' => t('Month'), 'table' => t('Table')), t('The default event view to display when no format is specifically requested. This is also the view that will be displayed from the block calendar links.'));
  $group .= form_textfield(t('Table view default period'), 'event_table_duration', variable_get('event_table_duration', '30'), 5, 3, t('The default number of days to display in the table view. You can specify a different number of days in the url. More info on the event url format %link', array('%link' => l(t('here'), 'admin/help/event#url-format'))));

  if (module_exist('taxonomy')) {
    $group .= form_radios('Taxonomy filter controls', 'event_taxonomy_control',
              variable_get('event_taxonomy_control', 'all'),
              array('all' => t('Show taxonomy filter control on calendar views'),
              'request' => t('Only show taxonomy filter control when taxonomy filter view is requested'),
              'never' => t('Never show taxonomy filter control')));
  }
  $group .= form_radios('Content type filter controls', 'event_type_control',
            variable_get('event_type_control', 'all'),
            array('all' => t('Show content type filter control on calendar views'),
            'request' => t('Only show content type filter control when content type filter view is requested'),
            'never' => t('Never show content type filter control')));

  $output .= form_group(t('Event overview options'), $group);

  return $output;
}

/**
 * @defgroup event_callback Functions which are the menu callbacks for this module
 */

/**
 * Displays a page containing event information.  The page layout defaults to a graphical calendar.
 *
 * @ingroup event_callback
 * @return the content for the event page.
 */
function event_page($year = NULL, $month = NULL, $day = NULL, $view = NULL, $types = NULL, $tids = NULL, $duration = NULL) {

  // get local timestamp value
  $now = _event_user_time();

  // create request timestamp and date values
  $stamp = gmmktime(0, 0, 0, ($month ? $month : gmdate('m', $now)), ($day ? $day : gmdate('d', $now)), ($year ? $year : gmdate('Y', $now)));
  $year = gmdate('Y', $stamp);
  $month = gmdate('m', $stamp);
  $day = gmdate('d', $stamp);

  $view = $view ? $view : variable_get('event_overview', 'next');

  if ($_POST['edit']['event_type_select']) {
    drupal_goto('event/'. $year .'/'. $month .'/'. $day .'/'. $view .'/'. $_POST['edit']['event_type_select'] .'/'. $tids);
  }

  if ($_POST['edit']['event_term_select']) {
    drupal_goto('event/'. $year .'/'. $month .'/'. $day .'/'. $view .'/'. ($types ? $types : 'all') .'/'. $_POST['edit']['event_term_select']);
  }

  $breadcrumbs[] = l(t('Home'), NULL);
  $breadcrumbs[] = l(t('Events'), 'event');

  if ($types) {
    // The '+' character in a query string may be parsed as ' '.
    $types = preg_split('/[+ ]/', $types);
    foreach ($types as $type) {
      if (is_numeric($type)) {
        $ctype = module_invoke('flexinode', 'load_content_type', $type);
        if ($ctype->name) {
          $temp[$ctype->name] = 'flexinode-'. $type;
          $filter[] = $ctype->name;
        }
      }
      elseif (substr($type, 0, 10) == 'flexinode-') {
        $ctype = module_invoke('flexinode', 'load_content_type', substr($type, 10));
        if ($ctype->name) {
          $temp[$ctype->name] = $type;
          $filter[] = $ctype->name;
        }
      }
      elseif ($name = module_hook($type, 'node_name')) {
        $x = module_invoke($type, 'node_name', $node);
        $temp[$x] = $type;
        $filter[] = module_invoke($type, 'node_name', $node);
      }
    }

    if (is_array($filter)) {
      $links[] = l(t('view all'), 'event/'. $year .'/'. $month .'/'. $day .'/'. $view .'/');
      $title =  t('Filter') .': ' .implode(', ', $filter);
      $types = $temp;
    }
    else {
      $types = null;
    }
  }

  $terms = null;
  if ($tids && $tids != 'all') {
    $links[] = l(t('view all'), 'event/'.$year.'/'.$month.'/'.$day.'/day');
    if (preg_match('/^([0-9]+[+ ])+[0-9]+$/', $tids)) {
      // The '+' character in a query string may be parsed as ' '.
      $terms = preg_split('/[+ ]/', $tids);
    }
    else if (preg_match('/^([0-9]+,)*[0-9]+$/', $tids)) {
      $terms = explode(',', $tids);
    }
  }

  // add taxonomy filter controls to top of calendar
  if (variable_get('event_taxonomy_control', 'all') == 'all' || (variable_get('event_taxonomy_control', 'all') == 'request' && isset($terms))) {
    $output .= _event_get_taxonomy_control($terms);
  }
  // add content type filter controls to top of calendar
  if (variable_get('event_type_control', 'all') == 'all' || (variable_get('event_type_control', 'all') == 'request' && isset($types))) {
    $output .= _event_get_type_control($types);
  }

  switch ($view) {
    case 'day':
        // day view
        $headertitle = t('%weekday %month %day, %year', array('%weekday' => t(gmdate('l', $stamp)), '%month' => t(gmdate('F', $stamp)), '%day' => $day, '%year' => $year));
        $rows = event_calendar_day('page', $stamp, $types, $terms);
      break;
    case 'week':
        // week view
        // setup calendar table header
        $temp = $stamp - (_event_day_of_week($stamp) * (86400));
        $headertitle = t('Week of %month %day, %year', array('%month' => t(gmdate('F', $temp)), '%day' => gmdate('d', $temp), '%year' => $year));
        $colspan = 5;
        $rows = event_calendar_week('page', $stamp, $types, $terms);
      break;
    case 'month':
        // month view
        $headertitle = t('%month %year', array('%month' => t(gmdate('F', $stamp)), '%year' => $year));
        $colspan = 5;
        $rows = event_calendar_month('page', $stamp, $types, $terms);
      break;
    case 'table':
        // table view
        // next 30 day view, $duration can be set for different ranges
        $duration = $duration ? $duration : variable_get('event_table_duration', '30');
        $endstamp = $stamp + ($duration * 86400);
        $headertitle = t('%startmonth %startdate, %startyear - %endmonth %enddate, %endyear', array('%startmonth' => gmdate('F', $stamp), '%startdate' => gmdate('d', $stamp), '%startyear' => gmdate('Y', $stamp), '%endmonth' => t(gmdate('F', $endstamp)), '%enddate' => gmdate('d', $endstamp), '%endyear' => gmdate('Y', $endstamp)));
        $rows = event_calendar_table('page', $stamp, $endstamp, $types, $terms);
      break;
  }

  // build header navigation
  $prev = _event_nav($stamp, 'prev', $view, $types, $terms, $duration);
  $next = _event_nav($stamp, 'next', $view, $types, $terms, $duration);

  // setup calendar table header
  $header = array(
    array('class' => 'prev', 'data' => $prev),
    array('class' => 'heading', 'data' => $headertitle, 'colspan' => $colspan),
    array('class' => 'next', 'data' => $next));

  $node->day = $day;
  $node->month = $month;
  $node->year = $year;
  $node->filter = ($types ? implode('+', $types) : 'all') .'/'. ($terms ? implode('+', $terms) : 'all');
  $output .= theme('event_links', array_merge(module_invoke_all('link', 'event_'. $view, $node, FALSE), $links), $view);

  $output .= theme('event_calendar_'. $view, 'page', $header, $rows);

  drupal_set_title(t('Events') . ($title ? ' - '. $title : ''));
  drupal_set_breadcrumb($breadcrumbs);
  print theme('page', $output);
}

/**
 * Url wrapper function for static link to calendar by content type.
 *
 * @ingroup event_callback
 * @return redirect to the event page for calendar node type.
 */
function event_type($types = NULL, $view = NULL, $terms = NULL) {
  drupal_goto('event/'. format_date(_event_user_time(), 'custom', 'Y/m/d') .'/'. ($view ? $view : variable_get('event_overview', 'next') .'/'. $types));
}

/**
 * Url wrapper function for static link to calendar by taxonomy terms.
 *
 * @ingroup event_callback
 * @return redirect to the event page for calendar taxonomy term.
 */
function event_term($filter = NULL, $view = NULL) {
  drupal_goto('event/'. format_date(_event_user_time(), 'custom', 'Y/m/d') .'/'. ($view ? $view : variable_get('event_overview', 'next') .'/all/'. $filter));
}

/**
 * @defgroup event_view Functions which handle the display of event nodes
 */

/**
 * Displays a monthly event calendar.
 *
 * @ingroup event_view
 * @return a themed monthly event calendar.
 */
function event_calendar_month($op, $stamp, $types = NULL, $terms = NULL) {

  $year = gmdate('Y', $stamp);
  $month = gmdate('m', $stamp);
  $day = gmdate('d', $stamp);

  switch ($op) {
    case 'page':
        // setup callback for data population
        $callback = 'event_render_day';
        $view = 'month';
      break;

    case 'block':
        // create navigation links
        $prev = _event_nav($stamp, 'prev', 'month', $types, $terms);
        $next = _event_nav($stamp, 'next', 'month', $types, $terms);

        $headertitle = l(t(gmdate('F', $stamp)) .' '. $year, 'event/'. $year .'/'. $month .'/'. $day .'/month');
        $header = array(
          array('class' => 'prev', 'data' => $prev),
          array('class' => 'heading', 'data' => $headertitle, 'colspan' => 5),
          array('class' => 'next', 'data' => $next));

        $callback = 'event_render_day_single';
        $view = 'block';
      break;
  }

  // get weekdays array and header information
  $weekdays = event_week_days();
  $rows[] = event_week_header();

  // get GMT current date value
  $today = _event_user_date();

  // name of the month
  $month_name = gmdate('M', $stamp);

  // timestamp of first day of month
  $curstamp = gmmktime(0, 0, 0, $month, 01, $year);

  // timestamp of last day in month
  $lastday = gmmktime(0, 0, 0, $month, gmdate('t', $stamp), $year);

  // pad the first week row array to fill up days in the previous month we don't build
  $row = array_fill(0, 6, '');
  // get the day of week offset value for the first day of the month
  $start = $offset = _event_day_of_week($curstamp);
  // render the month calendar
  while ($curstamp <= $lastday) {
    for ($x = $start; $x < 7; $x++) {
      $cur_day = (($week * 7) + ($x + 1) - $offset);
      $row[$x] = array(
        'class' => strtolower("$month_name ". $weekdays[$x]['day'] . ($curstamp == $today ? ' today' : '') . ($cur_day == $day ? ' selected' : '')),
        'id' => strtolower($month_name . $cur_day),
        'data' => $callback($year, $month, $cur_day, $view, $types, $terms));
      $curstamp += 86400;
      if ($curstamp > $lastday) {
        $x = 8;
      }
    }
    $week++;
    $start = 0;
    $rows[] = array_pad($row, 7, '&nbsp;');
    $row = array();
  }

  switch ($op) {
    case 'page':
        return $rows;
      break;
    case 'block':
        return theme("event_calendar_month", $op, $header, $rows);
      break;
  }
}

/**
 * Displays a weekly event calendar.
 *
 * @ingroup event_view
 * @return a themed weekly event calendar.
 */
function event_calendar_week($op, $stamp, $types = NULL, $terms = NULL) {
  // get weekdays array and header information
  $weekdays = event_week_days();
  $rows[] = event_week_header();

  // get GMT current date value
  $today = _event_user_date();

  // apply offset to goto first day of week
  $stamp -= (_event_day_of_week($stamp) * (86400));

  for ($x = 0; $x < 7; $x++) {
    $year = gmdate('Y', $stamp);
    $month = gmdate('m', $stamp);
    $cur_day = gmdate('j', $stamp);
    $month_name = gmdate('M', $stamp);

    $row[$x] = array(
      'class' => strtolower("$month_name ". $weekdays[$x]['day'] . ($stamp == $today ? ' today' : '') . ($cur_day == $day ? ' selected' : '')),
      'id' => strtolower($month_name . $cur_day),
      'data' => event_render_day($year, $month, $cur_day, 'week', $types, $terms));
    $stamp += 86400;
  }
  $rows[] = $row;
  return $rows;
}

/**
 * Displays a daily event calendar.
 *
 * @ingroup event_view
 * @return a themed daily event calendar.
 */
function event_calendar_day($op, $stamp, $types = NULL, $terms = NULL) {

  $today = _event_user_date();

  $year = gmdate('Y', $stamp);
  $month = gmdate('m', $stamp);
  $day = gmdate('j', $stamp);
  $dow = _event_day_of_week($stamp);
  $month_name = gmdate('M', $stamp);
  $weekdays = event_week_days();

  $rows[][] = array(
    'class' => strtolower("$month_name ". $weekdays[$dow]['day'] . ($stamp == $today ? ' today' : '')),
    'id' => strtolower($month_name . $day),
    'data' => event_render_day($year, $month, $day, 'day', $types, $terms),
    'colspan' => 3);

  return $rows;
}

/**
 * Creates a themed table of events.
 *
 * @ingroup event_view
 * @param $start The GMT starting date for the table. 
 * @param $end The GMT ending date for the table.
 * @return A fully themed table.
 */
function event_calendar_table($op, $stamp, $endstamp, $types = NULL, $terms = NULL) {

  $today = _event_user_date();

  while ($stamp <= $endstamp) {
    $year = gmdate('Y', $stamp);
    $month = gmdate('m', $stamp);
    $cur_day = gmdate('j', $stamp);
    $month_name = gmdate('M', $stamp);
    $dow = _event_day_of_week($stamp);
    $weekdays = event_week_days();

    $rows[][] = array('colspan' => 3,
                      'class' => strtolower("$month_name ". $weekdays[$dow]['day'] . ($stamp == $today ? ' today' : '') . ($cur_day == $day ? ' selected' : '')),
                      'id' => strtolower($month_name . $cur_day),
                      'data' => event_render_day($year, $month, $cur_day, 'table', $types, $terms));
    $stamp += 86400;
  }

  return $rows;
}

/**
 * Returns a calendar in the requested format, populated with the provided nodes.
 *
 * @ingroup event_view
 *
 * @param $view - The format of calendar to return. Possible values:
 *                "table": A tabular calendar.
 *                "month": A month calendar.
 *                "week": A week calendar.
 *                "day": A day calendar.
 *  @param $nodes – An associative array of nodes with nids for key values.
 *           Node objects must have GMT timestamp values for start ($node->start).
 *           Optionally, an end value ($node->end) and a timezone offset value
 *           in the same format as drupal core ($node->tz). If a node has no end
 *           value, it is rendered on only one day. If no timezone value is displayed
 *           the time is rendered with no timezone offset (GMT).
 *  @param $module - String containing the name of the module calling the function
 *  @param $title - A string value that will be printed into the header of the calendar
 *  @return Themed calendar view of nodes
 */
function event_get_calendar($view, $nodes, $module, $title = NULL) {
  $today = _event_user_date();

  foreach ($nodes as $node) {
    $node->event_links = module_invoke_all('link', 'event_node_'. $view, $node, FALSE);
    $nodes[$node->nid] = $node;
    $nid->nid = $node->nid;

    // $node_start and $node_end are local timestamp values
    $node_start = gmmktime(0, 0, 0, _event_date('m', $node->start, $node->tz), _event_date('d', $node->start, $node->tz), _event_date('Y', $node->start, $node->tz));
    if ($node->end) {
      $node_end = gmmktime(0, 0, 0, _event_date('m', $node->end, $node->tz), _event_date('d', $node->end, $node->tz), _event_date('Y', $node->end, $node->tz));
    }
    else {
      $node_end = $node_start;
    }

    if ($node_start == $node_end) {
      $nid->event_state = 'singleday';
      $nid->stamp = $node_start;
      $data[gmdate('Y', $node_start)][gmdate('m', $node_start)][gmdate('j', $node_start)][] = $nid;
    }
    else {
      // roll through each day the event occurs and set an entry for each
      for ($x = $node_start; $x <= $node_end; $x += 86400) {
        if ($x == $node_end) {
          $nid->event_state = 'end';
          $nid->stamp = $x;
          $data[gmdate('Y', $x)][gmdate('m', $x)][gmdate('j', $x)][] = $nid;
        }
        elseif ($x == $node_start) {
          $nid->event_state = 'start';
          $nid->stamp = $x;
          $data[gmdate('Y', $x)][gmdate('m', $x)][gmdate('j', $x)][] = $nid;
        }
        else {
          $nid->event_state = 'ongoing';
          $nid->stamp = $x;
          $data[gmdate('Y', $x)][gmdate('m', $x)][gmdate('j', $x)][] = $nid;
        }
      }
    }
  }

  // order the years, months and days
  ksort($data, SORT_NUMERIC);
  foreach($data as $year => $months) {
    ksort($data[$year], SORT_NUMERIC);
    foreach($data[$year] as $month => $days) {
      ksort($data[$year][$month], SORT_NUMERIC);
    }
  }

  $weekdays = event_week_days();
  switch ($view) {
    case 'day':
    case 'table':
        foreach ($data as $year => $months) {
          if(count($data) > 1) {
            // add year heading
            $rows[][] = array(
                        'class' => 'heading year',
                        'id' => 'year'.$year,
                        'data' => $year);
          }
          foreach($months as $month => $days) {
            foreach($days as $day => $nids) {
              $content = theme('event_calendar_date_box', $year, $month, $day, 'table');
              foreach($nids as $nid) {
                if(!$month_name) {
                  $month_name = gmdate('M', $nid->stamp);
                  $dow = _event_day_of_week($nid->stamp);
                }
                $node = $nodes[$nid->nid];

                $node->event_state = $nid->event_state;

                $content .= theme('event_node_'. $view, $node, $module);
              }
              $rows[][] = array(
                'class' => strtolower("$month_name ". $weekdays[$dow]['day'] . ($nid->stamp == $today ? ' today' : '')),
                'id' => strtolower($month_name . $day),
                'data' => $content);
              $month_name = NULL;
            }
          }
        }
      break;

    case 'week':
    case 'month':
        $colspan = '7';
        foreach ($data as $year => $months) {
          if(count($data) > 1) {
            // add year heading
            $rows[][] = array(
                        'class' => 'heading year',
                        'id' => 'year'. $year,
                        'data' => $year,
                        'colspan' => $colspan);
          }
          foreach ($months as $month => $days) {
            // timestamp of first day in month
            $curstamp = gmmktime(0, 0, 0, $month, 1, $year);
            // timestamp of last day in month
            $lastday = gmmktime(0, 0, 0, $month, gmdate('t', $curstamp), $year);
            // pad the first week row array to fill up days in the previous month we don't build
            $row = array_fill(0, 6, '');
            // get the day of week offset value for the first day of the month
            $start = $offset = _event_day_of_week($curstamp);
            // get name of month
            $month_name = gmdate('M', $curstamp);
            // set week counter
            $week = 0;
            // add month header
            $rows[][] = array(
                        'class' => 'heading month',
                        'id' => 'month'. $month,
                        'data' => $month_name,
                        'colspan' => $colspan);
            $rows[] = event_week_header();

            while ($curstamp <= $lastday) {
              for ($x = $start; $x < 7; $x++) {
                $cur_day = (($week * 7) + ($x + 1) - $offset);

                $content = theme('event_calendar_date_box', $year, $month, $cur_day, $view);

                // render nodes for the day
                if(is_array($days[$cur_day])) {
                  foreach($days[$cur_day] as $nid) {
                    $node = $nodes[$nid->nid];
                    $node->event_state = $nid->event_state;
                    $content .= theme('event_node_'. $view, $node, $module);
                  }
                }

                $row[$x] = array(
                  'class' => strtolower("$month_name ". $weekdays[$x]['day'] . ($curstamp == $today ? ' today' : '')),
                  'id' => strtolower($month_name . $day),
                  'data' => $content);

                $curstamp += 86400;
                if ($curstamp > $lastday) {
                  $x = 8;
                }
              }
              $week++;
              $start = 0;
              $rows[] = array_pad($row, 7, '&nbsp;');
              $row = array();
            }
          }
        }
      break;
  }

  $header[] = ($title ? array('class' => 'heading', 'data' => $title, 'colspan' => $colspan) : array());
  return theme('event_calendar_'. $view, 'page', $header, $rows);
}

/**
 * @defgroup event_support Functions that support the event system
 */


/**
 * Returns an array of nodes that occur on a given date.
 * Handles content type and taxonomy filters.
 *
 * @ingroup event_support
 * @param $year The year the event is taking place.
 * @param $month The month the event is taking place.
 * @param $day The day the event is taking place. No leading zeroes.
 * @return An array containing all of the events taking place on the specified date, or an empty array if none exist.
 */
function event_calendar_data($year, $month, $day, $view = NULL, $types = NULL, $terms = NULL) {
  static $data;
  global $user;

  $day_start = _event_mktime(0, 0, 0, $month, $day, $year);

  if (!is_array($data[$year][$month])) {
    $data[$year][$month] = array();

    // get GMT values from local date values for db query
    $first = _event_mktime(0, 0, 0, $month, 1, $year);
    $last = _event_mktime(23, 59, 59, $month + 1, 0, $year);

    $result = db_query(db_rewrite_sql('SELECT n.nid FROM {event} e INNER JOIN {node} n USING (nid) WHERE n.status = 1 AND ((e.start > %d AND e.start < %d) OR (e.end > %d AND e.end < %d) OR (e.start < %d AND e.end > %d)) ORDER BY e.start '), $first, $last, $first, $last, $first, $last);

    while ($nid = db_fetch_object($result)) {
      $node = node_load(array('nid' => $nid->nid));

      // we have to load these here since there is no way to pass the $view parameter to nodeapi through node_load :/
      $node->event_links = module_invoke_all('link', 'event_node_'. $view, $node, FALSE);

      // this array contains the loaded nodes for the month, so we dont have them stored for every day they occur
      $data[$year][$month]['nodes'][$nid->nid] = $node;

      // get local timestamp (date only) value for the node's GMT timestamps
      $tz = ((variable_get('event_timezone_display', 'event') == 'user') ? $user->timezone : $node->tz);
      $node_start = gmmktime(0, 0, 0, _event_date('m', $node->start, $tz), _event_date('d', $node->start, $tz), _event_date('Y', $node->start, $tz));
      $node_end = gmmktime(0, 0, 0, _event_date('m', $node->end, $tz), _event_date('d', $node->end, $tz), _event_date('Y', $node->end, $tz));

      if (($node_start == $node_end) && (gmdate('m', $node_start) == $month)) {
        $nid->event_state = 'singleday';
        $data[$year][$month][gmdate('j', $node_start)][] = $nid;
      }
      else {
        // because $first is a local timestamp we compensate for the tz offset here so we dont have to do day value comparisons over and over below
        $first -= ($first % 86400);
        // roll through each day the event occurs and set an entry for each
        for ($x = ($first > $node_start ? $first : $node_start); $x < $last; $x += 86400) {
          if (gmdate('m', $x) == $month) {
            if ($x == $node_end) {
              $nid->event_state = 'end';
              $data[$year][$month][gmdate('j', $x)][] = $nid;
              $x = $last + 1;
            }
            elseif ($x == $node_start) {
              $nid->event_state = 'start';
              $data[$year][$month][gmdate('j', $x)][] = $nid;
            }
            else {
              $nid->event_state = 'ongoing';
              $data[$year][$month][gmdate('j', $x)][] = $nid;
            }
          }
        }
      }
    }
  }

  $nodes = array();
  $event_types = event_get_types();
  if ($data[$year][$month][$day]) {
    if (isset($types)) {
      // content type filters set
      if (isset($terms)) {
        // taxonomy and content type filters set
        foreach ($data[$year][$month][$day] as $nid) {
          $node = $data[$year][$month]['nodes'][$nid->nid];
          if (in_array($node->type, $types) && event_taxonomy_filter($node, $terms)) {
            // this node is the content type and taxonomy term requested
            if (count($types) == 1 && in_array($node->type, $event_types['solo'])) {
              // only display solo types if there is only one event type requested
              $node->event_current_date = $day_start;
              $node->event_state = $nid->event_state;
              $nodes[] = $node;
            }
            elseif (in_array($node->type, $event_types['all'])) {
              $node->event_current_date = $day_start;
              $node->event_state = $nid->event_state;
              $nodes[] = $node;
            }
          }
        }
      }
      else {
        // only content type filters
        foreach ($data[$year][$month][$day] as $nid) {
          $node = $data[$year][$month]['nodes'][$nid->nid];
          if (in_array($node->type, $types)) {
            if (count($types) == 1 && in_array($node->type, $event_types['solo'])) {
              // only display solo types if there is only one event type requested
              $node->event_current_date = $day_start;
              $node->event_state = $nid->event_state;
              $nodes[] = $node;
            }
            elseif (in_array($node->type, $event_types['all'])) {
              $node->event_current_date = $day_start;
              $node->event_state = $nid->event_state;
              $nodes[] = $node;
            }
          }
        }
      }
    }
    elseif (isset($terms)) {
      // no types, only taxonomy filters
      foreach ($data[$year][$month][$day] as $nid) {
        $node = $data[$year][$month]['nodes'][$nid->nid];
        if (event_taxonomy_filter($node, $terms) && in_array($node->type, $event_types['all'])) {
          $node->event_current_date = $day_start;
          $node->event_state = $nid->event_state;
          $nodes[] = $node;
        }
      }
    }
    else {
      foreach ($data[$year][$month][$day] as $nid) {
        // no filters set, only show events with content types states of 'all'
        $node = $data[$year][$month]['nodes'][$nid->nid];
        if (in_array($node->type, $event_types['all'])) {
          $node->event_current_date = $day_start;
          $node->event_state = $nid->event_state;
          $nodes[] = $node;
        }
      }
    }
  }

  return $nodes;
}

function event_taxonomy_filter($node, $terms) {
  if ($tids = taxonomy_node_get_terms($node->nid)) {
    foreach ($tids as $tid => $term) {
      if (in_array($tid, $terms)) {
        return TRUE;
      }
    }
  }
  return FALSE;
}

/**
 * Returns a link to the event page for a single day.
 *
 * @ingroup event_support
 * @param $year The year the event is taking place.
 * @param $month The month the event is taking place.
 * @param $day The day the event is taking place. No leading zeroes
 * @return The value of the day requested. If the day has events, the value will be a link to a more detailed page of that day's events.
 */
function event_render_day_single($year, $month, $day, $view, $types, $terms) {
  return count(event_calendar_data($year, $month, $day)) ? l($day, "event/$year/$month/$day") : $day;
}

/**
 * Returns an day of events for a calendar.
 *
 * @ingroup event_support
 * @param $year The year the event is taking place.
 * @param $month The month the event is taking place.
 * @param $day The day the event is taking place. No leading zeroes.
 * @return A string containing all of the events taking place.
 */
function event_render_day($year, $month, $day, $view, $types, $terms) {

  $output = theme('event_calendar_date_box', $year, $month, $day, $view);

  $nodes = event_calendar_data($year, $month, $day, $view, $types, $terms);

  if (count($nodes)) {
    foreach ($nodes as $node) {
      $output .= theme('event_node_'. $view, $node);
    }
  }
  else {
    $output .= theme('event_empty_day', $view);
  }

  return $output;
}

/**
 * Returns week day names and thier translated values, corrected for the start of week day settings (mon or sun)
 *
 * @ingroup event_support
 * @return an associative array containing weekday names
 */
function event_week_days() {
  static $weekdays;

  if (!$weekdays) {
    if (variable_get('date_first_day', 1)) {
      $weekdays = array(array('day' => 'Mon', 't' => t('Mon')), array('day' => 'Tue', 't' => t('Tue')), array('day' => 'Wed', 't' => t('Wed')), array('day' => 'Thu', 't' => t('Thu')), array('day' => 'Fri', 't' => t('Fri')), array('day' => 'Sat', 't' => t('Sat')), array('day' => 'Sun', 't' => t('Sun')));
    }
    else {
      $weekdays = array(array('day' => 'Sun', 't' => t('Sun')), array('day' => 'Mon', 't' => t('Mon')), array('day' => 'Tue', 't' => t('Tue')), array('day' => 'Wed', 't' => t('Wed')), array('day' => 'Thu', 't' => t('Thu')), array('day' => 'Fri', 't' => t('Fri')), array('day' => 'Sat', 't' => t('Sat')));
    }
  }
  return $weekdays;
}

/**
 * Formats the weekday information into table header format
 *
 * @ingroup event_support
 * @return array with weekday table header data
 */
function event_week_header() {
  // create week header
  $days = event_week_days();

  foreach ($days as $day) {
    $row[] = array('class' => strtolower("days ". $day['day']), 'data' => $day['t']);
  }

  return $row;
}

/**
 * Formats a GMT timestamp to local date values using timezone offset supplied.
 * All timestamp values in event nodes are GMT and translated for display here.
 *
 * Timezone settings are applied in the following order
 * 1. If supplied, timezone offset is applied
 * 2. If user timezones are enabled, user timezone offset is applied
 * 3. If neither 1 nor 2 apply, the site timezone offset is applied
 *
 * @param $format The date() format to apply to the timestamp.
 * @param $timestamp The GMT timestamp value.
 * @param $timezone Timezone offset to apply to the timestamp.
 * @ingroup event_support
 * @return gmdate() formatted date value
 */
function _event_date($format, $timestamp, $timezone = null) {
  global $user;

  if (isset($timezone)) {
    $timestamp += $timezone;
  }
  elseif (variable_get('configurable_timezones', 1) && $user->uid && strlen($user->timezone)) {
    $timestamp += $user->timezone;
  }
  else {
    $timestamp += variable_get('date_default_timezone', 0);
  }

  // make sure we apply the site first day of the week setting for dow requests
  if ($format == 'w') {
    $result = _event_day_of_week($timestamp);
  }
  else {
    $result = gmdate($format, $timestamp);
  }
  return  $result;
}

// return the day of week with start of week offset applied
function _event_day_of_week($stamp) {
  $dow = gmdate('w', $stamp);
  $dow = (variable_get('date_first_day', 1) ? ($dow == 0 ? 6 : --$dow ) : $dow);
  return $dow;
}

/**
 * Formats local time values to GMT timestamp using timezone offset supplied.
 * All time values in the database are GMT and translated here prior to insertion.
 *
 * Timezone settings are applied in the following order:
 * 1. If supplied, timezone offset is applied
 * 2. If user timezones are enabled, user timezone offset is applied
 * 3. If neither 1 nor 2 apply, the site timezone offset is applied
 *
 * @param $format The date() format to apply to the timestamp.
 * @param $timestamp The GMT timestamp value.
 * @param $timezone Timezone offset to apply to the timestamp.
 * @ingroup event_support
 * @return gmdate() formatted date value
 */
function _event_mktime($hour, $minute, $second, $month, $day, $year, $timezone = NULL) {
  global $user;
  $timestamp = gmmktime($hour, $minute, $second, $month, $day, $year);
  if (isset($timezone)) {
    return $timestamp - $timezone;
  }
  elseif (variable_get('configurable_timezones', 1) && $user->uid && strlen($user->timezone) && (variable_get('event_timezone_display', 'event') == 'user')) {
    return $timestamp - $user->timezone;
  }
  else {
    return $timestamp - variable_get('date_default_timezone', 0);
  }
}

// returns a local timestamp based on the user or site timezone
function _event_user_time() {
  global $user;

  if (variable_get('configurable_timezones', 1) && $user->uid && strlen($user->timezone)) {
    return time() + $user->timezone;
  }
  else {
    return time() + variable_get('date_default_timezone', 0);
  }
}

// returns a local timestamp value corrected with the user or site timezone with time information set to 0
function _event_user_date() {
  static $date;
  if (!$date) {
    $now = _event_user_time();
    $date = gmmktime(0, 0, 0, gmdate('m', $now), gmdate('j', $now), gmdate('Y', $now));
  }
  return $date;
}

/**
 * Constructs the time select boxes.
 *
 * @ingroup event_support
 * @param $timestamp The time already selected.  This is applicable if the user is editing an event.
 * @param $prefix The value to prepend to the select element names, used for start and end times.
 * @return A set of select boxes that contain options for month, day, year, hour, and minute
 */
function event_form_date($timestamp, $prefix = 'start', $timezone) {
  //determine settings for form's hour selector
  if (variable_get('event_ampm', '0')) {
    $hour_format = t('g');
    $first_hour = 1;
    $last_hour = 12;
  }
  else {
    $hour_format = t('H');
    $first_hour = 0;
    $last_hour = 23;
  }

  $date = getdate(gmmktime());
  $curyear = $date['year'];
  while ($i < 10) {
    $years[$curyear + $i] = $curyear + $i;
    $i++;
  }

  $months = array(1 => t('January'), t('February'), t('March'), t('April'), t('May'), t('June'), t('July'), t('August'), t('September'), t('October'), t('November'), t('December'));
  for ($i = 1; $i <= 31; $i++) $days[$i] = $i;
  for ($i = $first_hour; $i <= $last_hour; $i++) $hours[$i] = $i;
  for ($i = 0; $i <= 59; $i++) $minutes[$i] = $i < 10 ? "0$i" : $i;
  $am_pms = array('am' => t('am'), 'pm' => t('pm'));

  // This is a GMT timestamp, so we use our wrapper _event_date() to display values.
  $year = _event_date('Y', $timestamp, $timezone);
  $month = _event_date('m', $timestamp, $timezone);
  $day = _event_date('d', $timestamp, $timezone);
  $hour = _event_date($hour_format, $timestamp, $timezone);
  $minute = _event_date('i', $timestamp, $timezone);
  $am_pm = _event_date('a', $timestamp, $timezone);

  $when = '<div class="container-inline">';
  $when .= '<div class="day">';
  $when .= form_select('', $prefix .'month', $month, $months);
  $when .= form_textfield('', $prefix .'day', $day, 2, 2);
  $when .= ', ';
  $when .= form_textfield('', $prefix .'year', $year, 4, 4);
  $when .= '</div><div class="time">';
  $when .= form_select('', $prefix .'hour', $hour, $hours);
  $when .= ':';
  $when .= form_select('', $prefix .'minute', $minute, $minutes);
  if (variable_get('event_ampm', '0')) {
    $when .= form_select('', $prefix .'ampm', $am_pm, $am_pms);
  }
  $when .= '</div></div>';

  return $when;
}

/**
 * Validates the start and end times in a node form submission.
 * - Changes 24 hour time to 12 hour time (if the module is configured to do this).
 *  - Adjusts times for timezone offsets.
 *
 * @ingroup event_support
 * @param $node The submitted node with form data.
 * @param $prefix The prefix to validate and set (start and end).
 */
function event_validate_form_date(&$node, $prefix) {
  // Re-calculate $node->start if we have all the parameters.
  if (isset($node->{$prefix . 'year'}) && isset($node->{$prefix . 'month'}) && isset($node->{$prefix . 'day'}) && isset($node->{$prefix . 'hour'}) && isset($node->{$prefix . 'minute'})) {
    $hour = $node->{$prefix . 'hour'};
    if (variable_get('event_ampm', '0')) {
      if (($node->{$prefix . 'ampm'} == 'pm') && ($hour != 12)) {
        $hour += 12;
      }
      elseif (($node->{$prefix . 'ampm'} == 'am') && ($hour == 12)) {
        $hour -= 12;
      }
    }
    // translate the input values to GMT and set the node property value
    $node->$prefix = _event_mktime($hour, $node->{$prefix . 'minute'}, 0, $node->{$prefix . 'month'}, $node->{$prefix . 'day'}, $node->{$prefix . 'year'}, $node->tz);
  }
  elseif (!$node->$prefix) {
    // Round to nearest hour:
    $now = _event_user_time();
    $node->$prefix = $now - ($now % (60 * 60));
  }
}

function event_zonelist() {
  $timestamp = time();
  $zonelist = array('Rawaki' => -12,
                    'Samoa, Midway' => -11,
                    'Hawaii, French Polynesia, Cook Island' => -10,
                    'Iles Marquises - French Polynesia' => -9.5,
                    'Alaska' => -9,
                    'US Pacific' => -8,
                    'US Mountain' => -7,
                    'US Central' => -6,
                    'US Eastern' => -5,
                    'New Foundland, Venezuela, Chile' => -4,
                    'St. John\'s, Canada, Newfoundland and Labrador' => -3.5,
                    'Brazil, Argentina, Greenland' => -3,
                    'Mid-Atlantic' => -2,
                    'Azores, Cape Verda Is.' => -1,
                    'England, Ireland, Portugal' => 0,
                    'Central Europe' => 1,
                    'Eastern Europe' => 2,
                    'Moscow, Saudi Arabia' => 3,
                    'Iran' => 3.5,
                    'Oman' => 4,
                    'Pakistan' => 5,
                    'India, West Bengal' => 5.5,
                    'Nepal, Bagmati' => 5.75,
                    'India' => 6,
                    'South-East Asia, Cocos Islands' => 6.5,
                    'Indonesia, Central Russia' => 7,
                    'China, Phillipines, Malaysia, West Australia' => 8,
                    'Japan' => 9,
                    'Central Australia' => 9.5,
                    'East Australia' => 10,
                    'Lord Howe Island, Australia' => 10.5,
                    'Solomon Islands, Micronesia' => 11,
                    'Pacific - Norfolk Island' => 11.5,
                    'New Zealand, Marshall Islands, Fiji' => 12,
                    'Chatham Islands, New Zealand' => 12.75,
                    'Oceania, Tonga' => 13,
                    'Pacific - Kiribati' => 14);
  $zones = array();
  foreach ($zonelist as $key => $offset) {
    $zone = $offset * 3600;
    $zones[$zone] =  $offset .': '. t($key);
  }
  return $zones;
}

/**
 * Build the navigation links for the calendar views
 *
 * @ingroup event_support
 * @param $date The GMT date we are viewing
 * @param $dir The 'direction' we want (prev or next)
 * @param $view The view we are navigating, month, week, day or table
 * @param $types The content types to filter by
 * @param $terms The taxonomy terms to filter by
 * @param $duration The duration of the current view in multiples of view type
 * @return Themed navigation link.
 */
function _event_nav($date, $dir, $view, $types, $terms, $duration = NULL) {

  // first, retrieve the stored timestamp of the first/last event
  $range = variable_get('event_range_'. $dir, $date);

  // if we are beyond the range of the stored events, dont display navigation
  if (($dir == 'prev' && $range < $date) || ($dir == 'next' && $range > $date)) {
    $inc = ($dir == 'prev' ? -1 : 1);
    $duration = ($duration ? $duration : 1);

    switch ($view) {
      case 'day':
      case 'table':
          // Increment by $duration*days
          $date += ($inc * ($duration * 86400));
        break;
      case 'week':
          // Increment by $duration*weeks
          $date += ($inc * ($duration * (86400 * 7)));
        break;
      case 'month':
          // Increment by $duration*months
          $date = gmmktime(0, 0, 0, gmdate('m', $date) + ($duration * $inc), gmdate('j', $date), gmdate('Y', $date));
        break;
    }

    $url[] = 'event';
    $url[] = gmdate('Y', $date);
    $url[] = gmdate('m', $date);
    $url[] = gmdate('d', $date);
    $url[] = $view;
    $url[] = ($types ? implode('+', $types) : 'all');
    $url[] = ($terms ? implode('+', $terms) : 'all');
    $url[] = $duration;
    return theme('event_nav_'. $dir, implode('/', $url));
  }
}

/**
* Returns a dropdown event taxonomy term input control.
*
* @ingroup event_support.
* @param $curterm The current term id.
* @param $submit Adds 'onChange' form submit javascript command to control.
* @return A form with a dropdown event taxonomy term input control.
*/
function _event_get_taxonomy_control($curterm = NULL, $autosubmit = TRUE) {
  if (module_exist('taxonomy')) {
    $types = event_get_types();
    $vs = array();
    foreach ($types['all'] as $type) {
      $results = taxonomy_get_vocabularies($type);
      foreach ($results as $vocab) {
        $vs[$vocab->vid] = $vocab;
      }
    }

    $results = null;
    foreach ($types['solo'] as $type) {
      $results = taxonomy_get_vocabularies($type);
      foreach ($results as $vocab) {
        $vs[$vocab->vid] = $vocab;
      }
    }

    $items['all'] = '(all)';
    foreach ($vs as $vid => $vocab) {
      $tree = taxonomy_get_tree($vid);
      foreach ($tree as $term) {
        $items[$term->tid] = $vocab->name.' - '.$term->name;
      }
    }

    $select = form_select('', 'event_term_select', $curterm, $items, t('Select event terms to filter by'), ($autosubmit ? 'onChange="this.form.submit()"' : ''));

    $form = form($select);

    return theme('event_filter_control', $form);
  }
}

/**
* Returns a dropdown event-enabled content type input control.
*
* @ingroup event_support.
* @param $tid The current term id.
* @param $submit Adds 'onChange' form submit javascript command to control.
* @return A form with a dropdown event taxonomy term input control.
*/
function _event_get_type_control($curtype = NULL, $autosubmit = TRUE) {
  if (module_exist('taxonomy')) {
    $results = event_get_types('all');

    $items['all'] = '(all)';
    foreach ($results as $type) {
      if (module_hook($type, 'node_name')) {
        $items[$type] = module_invoke($type, 'node_name', $node);
      }
      elseif ($ctype = module_invoke('flexinode', 'load_content_type', substr($type, 10))) {
        $items[$type] = $ctype->name;
      }
    }

    $select = form_select('', 'event_type_select', $curtype, $items, t('Select event type to filter by'), ($autosubmit ? 'onChange="this.form.submit()"' : ''));

    $form = form($select);

    return theme('event_filter_control', $form);
  }
}

/**
 * @defgroup event_block Functions for event blocks.
 */

/**
 * Provides the blocks that this module is capable of displaying.
 *
 * @ingroup event_block
 * @param $op the operation that is being requested.  This defaults to 'list', which indicates that the method should
 *        return which blocks are available.
 * @param $delta the specific block to display.  This is actually the offset into an array.
 * @return one of two possibilities.  The first is an array of available blocks.  The other is an array containing a
 *        block.
 */
function event_block($op = 'list', $delta = 0) {
  switch ($op) {
    case 'list' :
      $blocks[0]['info'] = t('Calendar to browse events.');
      $blocks[1]['info'] = t('List of upcoming events.');
      return $blocks;
      break;
    case 'view' :
      if (user_access('access content')) {
        switch ($delta) {
          case 0:
            $time = _event_user_date();
            if (arg(0) == 'event') {
              // follow event calendar
              $year = (arg(1) ? arg(1) : gmdate('Y', $time));
              $month = (arg(2) ? arg(2) : gmdate('m', $time));
              $day = (arg(3) ? arg(3) : gmdate('d', $time));
              $stamp = gmmktime(0, 0, 0, $month, $day, $year);
            }
            else {
              $stamp = _event_user_date();
            }
            $block['subject'] = t('Events');
            $block['content'] = event_calendar_month('block', $stamp);
            return $block;
          case 1:
            $block['subject'] = t('Upcoming events');
            $block['content'] = event_block_upcoming();
            $block['content'] .= '<div class="more-link">'. l(t('more'), 'event', array('title' => t('More events.'))) .'</div>';
            return $block;
        }
      }
      break;
  }
}

/**
* Creates a block that contains upcoming events.
*
* @ingroup event_block
* @param $limit The number of events that can be displayed in the block.
* @return A string containing the fully themed block.
*/
function event_block_upcoming($limit = 6) {
  global $user;
  // For two hours, we display "NOW"
  $time = _event_user_time() - (2 * 60 * 60);
  $result = db_query_range(db_rewrite_sql("SELECT n.nid, n.title, n.type, n.status, n.moderate, e.start FROM {node} n INNER JOIN {event} e USING (nid) WHERE n.status = 1 AND n.moderate = 0 AND e.start >= $time ORDER BY e.start"), 0, $limit);

  while ($node = db_fetch_object($result)) {
    $links[] = $node;
  }

  if (is_array($links) && (sizeof($links) > 0)) {
    foreach ($links as $node) {
      $minutesleft = floor(($node->start - time()) / 60);

      if ($minutesleft < 0) {
        $timeleft = t('NOW');
      }
      else if ($minutesleft < 60) {
        $timeleft = format_plural($minutesleft, '1 minute', '%count minutes');
      }
      else if ($minutesleft >= 60 && $minutesleft < (24 * 60)) {
        $timeleft = format_plural(floor($minutesleft / 60), '1 hour', '%count hours');
      }
      else if ($minutesleft >= (24 * 60)) {
        $days = floor($minutesleft / (24 * 60));
        // hours remainder
        $hours = ($minutesleft % (24 * 60)) / 60;
        // hours left in the day
        $hours_left = ((time() / 60) % (24 * 60)) / 60;
        // see if the remainder of hours on the event date is greater than the hours left in today, if so increase the days by one so that the days remaining mimics the date rather than how many 24 hour periods there are between now and then.
        if ($hours>$hours_left) {
          $days++;
        }
        $timeleft = format_plural($days, '1 day', '%count days');
      }

      $ctype = module_invoke('flexinode', 'load_content_type', substr($node->type, 10));

      $items[] = l($node->title, "node/$node->nid", array("title" => $node->title)). '&nbsp;(' .($ctype->name ? $ctype->name : $node->type). ')<br />' ." ($timeleft)";
    }
    return theme("item_list", $items);
  }
}

/**
 * @defgroup event_nodeapi Functions for nodeapi integration
 */

 /**
 * hook_nodeapi implementation
 *
 * @ingroup event_nodeapi
 */
function event_nodeapi(&$node, $op, $arg = 0) {
  switch ($op) {
     case 'settings':
       return form_radios(t('Show in event calendar'), 'event_nodeapi_'. $node->type, variable_get('event_nodeapi_'. $node->type, 'never'), array('never' => t('Never'), 'all' => t('All views'), 'solo' => t('Only in views for this type')), t('None: This content type will not be associated with the events calendar.<br />All views: This content type will be available for display on all calendar views, including with other events.<br />Only in views for this type: This content type will only appear in calendar views specific to this type and never with other events.'));

    case 'form post':
      $form = '';
      if (variable_get('event_nodeapi_'. $node->type, 'never') != 'never') {
          global $user;
          $form = form_item(t('Start'), event_form_date(($node->start ? $node->start : _event_user_time()), 'start', $node->tz), t('Start date.'));

          $form .= form_item(t('End'), event_form_date($node->end, 'end', $node->tz), t('End date.'));

          if (variable_get('event_timezone_input', 'site') == 'input') {
            $form .= form_select(t('Time zone'), 'tz', $node->tz, event_zonelist(), t('Select the time zone this event occurs in.'));
          }
          elseif (variable_get('configurable_timezones', 1) && $user->uid && strlen($user->timezone) && (variable_get('event_timezone_input', 'site') == 'user')) {
            $form .= form_hidden('tz', $user->timezone);
          }
          else {
            $form .= form_hidden('tz', variable_get('date_default_timezone', 0));
          }
      }
      return $form;

    case 'validate':
      if (variable_get('event_nodeapi_'. $node->type, 'never') != 'never') {
        event_validate_form_date($node, 'start');
        event_validate_form_date($node, 'end');
        if ($node->end < $node->start) {
          $node->end = $node->start;
        }
        $node->start_format = format_date($node->start, 'small', '', $node->tz);
        $node->end_format = format_date($node->end, 'small', '', $node->tz);
      }
      break;

    case 'insert':
      if (variable_get('event_nodeapi_'. $node->type, 'never') != 'never') {
        $fields = array('nid', 'start', 'end');
        db_query('INSERT INTO {event} (nid, start, end, tz) VALUES (%d, %d, %d, %d)', $node->nid, $node->start, $node->end, $node->tz);
      }
      event_set_range();
      break;

    case 'update':
      if (variable_get('event_nodeapi_'. $node->type, 'never') != 'never') {
        $fields = array('start', 'end');
        db_query('UPDATE {event} SET start = %d, end = %d, tz = %d WHERE nid = %d', $node->start, $node->end, $node->tz, $node->nid);
      }
      event_set_range();
      break;

    case 'delete':
      if (variable_get('event_nodeapi_'. $node->type, 'never') != 'never') {
        db_query('DELETE FROM {event} WHERE nid = %d', $node->nid);
      }
      event_set_range();
      break;

    case 'load':
      if (variable_get('event_nodeapi_'. $node->type, 'never') != 'never') {
        $object = db_fetch_object(db_query('SELECT start, end, tz FROM {event} WHERE nid = %d', $node->nid));
        if (variable_get('event_timezone_display', 'event') == 'event') {
          $offset = $object->tz;
        }

        $ctype = module_invoke('flexinode', 'load_content_type', $node->ctype_id);

        return array('start' => $object->start,
                     'end' => $object->end,
                     'tz' => $object->tz,
                     'start_format' => format_date($object->start, 'small', '', $offset),
                     'end_format' => format_date($object->end, 'small', '', $offset),
                     'start_time_format' => format_date($object->start, 'custom', (variable_get('event_ampm', '0') ? 'g:i a' : 'H:i'), $offset),
                     'end_time_format' => format_date($object->end, 'custom', (variable_get('event_ampm', '0') ? 'g:i a' : 'H:i'), $offset),
                     'event_node_title' => ($ctype->name ? $ctype->name : $node->type));
      }
      break;

    case 'view':
      if (variable_get('event_nodeapi_'. $node->type, 'never') != 'never') {
        $node->body = theme('event_nodeapi', $node). $node->body;
        $node->teaser = theme('event_nodeapi', $node). $node->teaser;
      }
      break;
  }
}

function event_get_types($state = NULL) {
  static $types;
  if (!is_array($types)) {
    $types['all'] = array();
    $types['solo'] = array();
    $types['never'] = array();
    $result = db_query("SELECT * FROM {variable} WHERE name like 'event_nodeapi_%'");
    while ($type = db_fetch_object($result)) {
      $types[unserialize($type->value)][] = substr($type->name, 14);
    }
  }
  switch ($state) {
    case 'all':
        return $types['all'];
      break;
    case 'solo':
        return $types['solo'];
      break;
    case 'never':
        return $types['never'];
      break;
    default:
        return $types;
      break;
  }
}

function event_enabled_state($type) {
  $states = event_get_types();
  foreach ($states as $key => $state) {
    if (in_array($type, $state)) {
      return $key;
    }
  }
}

function event_is_enabled($type) {
  $states = event_get_types();
  return in_array($type, $states['all']);
}

function event_set_range() {
  $range = db_fetch_object(db_query('select MIN(e.start) AS start, MAX(e.end) AS end FROM {event} e'));
  variable_set('event_range_prev', $range->start);
  variable_set('event_range_next', $range->end);
}

/**
 * Displays the help text for this module.
 *
 * @ingroup event_core
 * @param $section the page which is requesting help
 * @return the help text
 * @todo Expand this section.
 */
function event_help($section) {
  switch ($section) {
    case 'admin/modules#description':
        return t('Lets users make events and keep calendars.');
      break;
    case 'admin/help#event':
      return t("
      <h3>Background</h3>
      <p>This version of event module implements the drupal nodeapi system. There is no native event node type as in versions previous to 4.6, but instead node types can be 'event-enabled' through the %configure-link, the same way in which file attachments are assigned to node types with upload.module. This, combined with the dynamic content type functionality of %flexinode-link, make it possible to define almost any kind of calendar.</p>
      <p>Node types can be assigned to general calendar views, or only on their own calendar. For example, this makes it possible to have a general calendar which shows all 'meetups' and 'house parties' in the same place, but perhaps have a separate calendar for 'rallies' which only contains that type. The ability to filter calendar views by node type and taxonomy is also implemented, which allows many different possibilities for displaying content in the calendar system.</p>
      
      <h3><a id=\"url-format\"></a>Calendar display url formats</h3>
      The ability to filter calendar views by content type and taxonomy enables almost unlimited possibilities for displaying content with the calendar system. You can combine taxonomy and content type filters, the url construction scheme is currently as follows:
      <blockquote>
      ?q=event/\$year/\$month/\$day/\$view_type/\$content_type/\$taxonomy_terms/\$duration<br /><br />
      <strong>\$year:</strong> year value such as '2005'<br />
      <strong>\$month:</strong> month value with leading zeroes such as '02' for february<br />
      <strong>\$day:</strong> day value with leading zeroes such as '14'<br />
      <strong>\$view_type:</strong> type of calendar layout, values may include 'month', 'week', 'day', and 'table'<br />
      <strong>\$content_type:</strong> list of node types, separated by '+'. Flexinode types only require the integer value of the type. For example, to view story nodes and type flexinode-1, you would use 'story+1'. The value 'all' will show all types.<br />
      <strong>\$taxonomy_terms:</strong> list of term ids, seperated by '+'. For example to view entries assigned to the taxonomy terms with ids 4 and 9 you would use '4+9'. The value 'all' will show all terms.<br />
      <strong>\$duration:</strong> number of days to display, currently only the table view obeys this setting. Eventually it may be used to specify additional duration parameters such as multiple weeks in the week view, or months in the month view.
      </blockquote>
      <p>There are url wrapper functions as well, which make it possible to easily create menu items to calendars by event type or taxonomy terms. This is necessary if you wish to create a link to a calendar but do not have a way to dynamically create the url based on the date, like in the menu or in a post.</p>
      <p>For links to a taxonomy filtered calendar the format is:
      <blockquote>
      ?q=event/term/\$taxonomy_terms<br /><br />
      <strong>\$taxonomy_terms:</strong> list of term ids, seperated by '+'. For example to view entries assigned to the taxonomy terms with ids 4 and 9 you would use '4+9'<br />
      </blockquote>
      For links to a content type filtered calendar the format is:
      <blockquote>
      ?q=event/type/\$content_type<br /><br />
      <strong>\$content_type:</strong> list of node types, separated by '+'. Flexinode types only require the integer value of the type. For example, to view story nodes and type flexinode-1, you would use 'story+1'
      </blockquote></p>",
      array('%configure-link' => l(t('content type management admin area'), 'admin/node/configure/types'), '%flexinode-link' => l(t('flexinode'), 'http://drupal.org/node/5737')));
      break;
  }
}
?>
