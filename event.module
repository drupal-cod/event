<?php
// $Id$ 

include(drupal_get_path('module', 'event') .'/event.theme');
include(drupal_get_path('module', 'event') .'/event_timezones.inc');
include(drupal_get_path('module', 'event') .'/ical.inc');

/**
 * @defgroup event_core Core drupal hooks
 */

/**
 * Provides a link to the CSS stylesheet associated with this module.
 *
 * @ingroup event_core
 * @return a &lt;style&gt; tag that indicates what file browsers should import
 */
function event_html_head() {
  $output = '<script type="text/javascript" src="'. drupal_get_path('module', 'event') .'/event.js"></script>';
  $output .= theme('stylesheet_import', drupal_get_path('module', 'event') .'/event.css','screen');
  return $output;
}

/**
 * Provides the links that should be displayed when viewing events.
 *
 * @ingroup event_core
 * @param $type the type of link (for example, 'node', 'page', or 'system') being requested
 * @param $node the node that is requesting the link.  This is used in conjunction with $type to further determine
 *        what sort of link to display.
 * @param $main unused in this method.
 * @return an array of links, or an empty array if no links apply for the criteria passed to this method.
 */
function event_link($type, $node = NULL, $teaser = FALSE) {
  switch ($type) {
    case 'node':
      if (event_enabled_state($node->type) == 'all') {
        $links[] = l(t('calendar'), 'event/'. format_date($node->event_start, 'custom', 'Y/m/d'));
      }
      elseif (event_enabled_state($node->type) == 'solo') {
        $links[] = l(t('calendar'), 'event/'. format_date($node->event_start, 'custom', 'Y/m/d') .'/month/'. $node->type);
      }
      break;
    case 'event_month':
      if (user_access('access content')) {
        $links[] = l(t('week'), "event/$node->year/$node->month/$node->day/week/". $node->filter, array('title' => t('Week view')));
        $links[] = l(t('day'), "event/$node->year/$node->month/$node->day/day/". $node->filter, array('title' => t('Day view')));
        $links[] = l(t('table'), "event/$node->year/$node->month/$node->day/table/". $node->filter, array('title' => t('Table view')));
        $links[] = l(t('list'), "event/$node->year/$node->month/$node->day/list/". $node->filter, array('title' => t('List view')));
      }
      break;
    case 'event_week':
      if (user_access('access content')) {
        $links[] = l(t('month'), "event/$node->year/$node->month/$node->day/month/". $node->filter, array('title' => t('Month view')));
        $links[] = l(t('day'), "event/$node->year/$node->month/$node->day/day/". $node->filter, array('title' => t('Day view')));
        $links[] = l(t('table'), "event/$node->year/$node->month/$node->day/table/". $node->filter, array('title' => t('Table view')));
        $links[] = l(t('list'), "event/$node->year/$node->month/$node->day/list/". $node->filter, array('title' => t('List view')));
      }
      break;
    case 'event_day':
      if (user_access('access content')) {
        $links[] = l(t('month'), "event/$node->year/$node->month/$node->day/month/". $node->filter, array('title' => t('Month view')));
        $links[] = l(t('week'), "event/$node->year/$node->month/$node->day/week/". $node->filter, array('title' => t('Week view')));
        $links[] = l(t('table'), "event/$node->year/$node->month/$node->day/table/". $node->filter, array('title' => t('Table view')));
        $links[] = l(t('list'), "event/$node->year/$node->month/$node->day/list/". $node->filter, array('title' => t('List view')));
      }
      break;
    case 'event_table':
      if (user_access('access content')) {
        $links[] = l(t('month'), "event/$node->year/$node->month/$node->day/month/". $node->filter, array('title' => t('Month view')));
        $links[] = l(t('week'), "event/$node->year/$node->month/$node->day/week/". $node->filter, array('title' => t('Week view')));
        $links[] = l(t('day'), "event/$node->year/$node->month/$node->day/day/". $node->filter, array('title' => t('Day view')));
        $links[] = l(t('list'), "event/$node->year/$node->month/$node->day/list/". $node->filter, array('title' => t('List view')));
      }
      break;
    case 'event_list':
      if (user_access('access content')) {
        $links[] = l(t('month'), "event/$node->year/$node->month/$node->day/month/". $node->filter, array('title' => t('Month view')));
        $links[] = l(t('week'), "event/$node->year/$node->month/$node->day/week/". $node->filter, array('title' => t('Week view')));
        $links[] = l(t('day'), "event/$node->year/$node->month/$node->day/day/". $node->filter, array('title' => t('Day view')));
        $links[] = l(t('table'), "event/$node->year/$node->month/$node->day/table/". $node->filter, array('title' => t('Table view')));
      }
      break;
  }
  return $links ? $links : array();
}

/**
 * Implementation of hook_menu()
 *
 * @ingroup event_core
 */
function event_menu($may_cache) {
  global $user;

  $items = array();
  if ($may_cache) {
    $items[] = array('path' => 'event',
                     'title' => t('events'),
                     'callback' => 'event_page',
                     'access' => user_access('access content'),
                     'type' => MENU_CALLBACK);
    $items[] = array('path' => 'event/additem',
                     'title' => t('add item to calendar'),
                     'callback' => 'event_add_item',
                     'access' => user_access('access content'),
                     'type' => MENU_CALLBACK);
    $items[] = array('path' => 'event/type',
                     'title' => t('filter by content type'),
                     'callback' => 'event_type',
                     'access' => user_access('access content'),
                     'type' => MENU_CALLBACK);
    $items[] = array('path' => 'event/term',
                     'title' => t('filter by taxonomy'),
                     'callback' => 'event_term',
                     'access' => user_access('access content'),
                     'type' => MENU_CALLBACK);
    $items[] = array('path' => 'event/feed',
                     'title' => t('event rss feed'),
                     'callback' => 'event_feed',
                     'access' => user_access('access content'),
                     'type' => MENU_CALLBACK);
    $items[] = array('path' => 'event/dst',
                     'title' => t('event dst view'),
                     'callback' => 'event_dst',
                     'access' => user_access('access content'),
                     'type' => MENU_CALLBACK);
    $items[] = array('path' => 'event/ical',
                     'title' => t('event ical feed'),
                     'callback' => 'event_ical',
                     'access' => user_access('access content'),
                     'type' => MENU_CALLBACK);
  }
  else {
    drupal_set_html_head(event_html_head());
  }
  return $items;
}

/**
 * Displays and allows an administrator to change the settings for this module.
 *
 * @ingroup event_core
 * @return the content for a settings page.
 */
function event_settings() {

  $form['event_settings_default'] = array('#type' => 'fieldset', '#title' => t('Timezone settings'));
  if (variable_get('configurable_timezones', 0)) {
    $form['event_settings_default']['event_timezone_input'] = array('#type' => 'radios', '#title' => t('Event time zone input'), '#default_value' =>  variable_get('event_timezone_input', 'site'), '#options' => array('site' => t('Use the sitewide time zone'), 'user' => t('Use the time zone of the user editing or creating the event'), 'input' => t('Allow users to set event time zones')), '#description' => t('Events are saved with a time zone value. This setting allows you to determine how the time zone is determined when creating or editing an event.'), '#required' => TRUE);

    $form['event_settings_default']['event_timezone_display'] = array('#type' => 'radios', '#title' => t('Event time zone display'), '#default_value' =>  variable_get('event_timezone_display', 'event'), '#options' => array('event' => t("Use the event's time zone"), 'user' => t("Use the user's time zone"), 'site' => t('Use the sitewide time zone')), '#description' => t("Events are saved with a time zone value. This setting allows you to determine if the event's time zone, the sitewide time zone, or the user's personal time zone setting is used to display the time for an event."), '#required' => TRUE);
  }
  else {
    if (variable_get('event_timezone_input', 'site') == 'user') {
      variable_set('event_timezone_input', 'site');
    }
    variable_set('event_timezone_display', 'event');

    $form['event_settings_default']['event_timezone_input'] = array('#type' => 'radios', '#title' => t('Event time zone input'), '#default_value' => variable_get('event_timezone_input', 'site'), '#options' => array('site' => t('Use the sitewide time zone'), 'user' => t('Use the time zone of the user editing or creating the event'), 'input' => t('Allow users to set event time zones')), '#description' => t("Events are saved with a time zone value. This setting allows you to determine how the time zone is determined when creating or editing an event. You must have 'Configurable time zones' enabled in %url before you can enable user's time zones for this feature.", array('%url' => l(t('site configuration'), 'admin/settings'))), '#required' => TRUE);

    $form['event_settings_default']['event_timezone_display'] = array('#type' => 'radios', '#title' => t('Event time zone display'), '#default_value' => variable_get('event_timezone_display', 'event'), '#options' => array('event' => t("Use the event's time zone"), 'site' => t('Use the sitewide time zone')), '#description' => t("Events are saved with a time zone value. This setting allows you to determine if the event's time zone, the sitewide time zone, or the user's personal time zone setting is used to display the time for an event. You must have 'Configurable time zones' enabled in %url before you can enable user's time zones for this feature.", array('%url' => l(t('site configuration'), 'admin/settings'))), '#required' => TRUE);
  }
  $form['event_settings_default']['event_ampm'] = array('#type' => 'radios', '#title' =>  t('Time notation preference'), '#default_value' => variable_get('event_ampm', '0'), '#options' => array('0' => t('24h'),'1' => t('12h')), '#description' => t('The time notation system used for entering event times.'), '#required' => TRUE);
  $form['event_settings_default']['event_upcoming_limit'] = array('#type' => 'textfield', '#title' => t('Upcoming event block limit'), '#default_value' => variable_get('event_upcoming_limit', '6'), '#maxlength' => 5, '#size' => 2, '#description' => t('Limit the amount of events displayed in the upcoming events block by this amount.'));

  $form['event_overview_options'] = array('#type' => 'fieldset', '#title' => t('Event overview options'));
  $form['event_overview_options']['event_overview'] = array('#type' => 'radios', '#title' => t('Default overview'), '#default_value' =>  variable_get('event_overview', 'month'), '#options' => array('day' => t('Day'), 'week' => t('Week'), 'month' => t('Month'), 'table' => t('Table'), 'list' => t('List')), '#description' => t('The default event view to display when no format is specifically requested. This is also the view that will be displayed from the block calendar links.'));
  $form['event_overview_options']['event_table_duration'] = array('#type' => 'textfield', '#title' => t('Table view default period'), '#default_value' => variable_get('event_table_duration', '30'), '#maxlength' =>  5, '#size' => 3, '#description' => t('The default number of days to display in the table view. You can specify a different number of days in the url. More info on the event url format %link', array('%link' => l(t('here'), 'admin/help/event#url-format'))));

  if (module_exist('taxonomy')) {
    $form['event_overview_options']['event_taxonomy_control'] = array('#type' => 'radios', '#title' => t('Taxonomy filter controls'), '#default_value' => variable_get('event_taxonomy_control', 'all'), '#options' => array('all' => t('Show taxonomy filter control on calendar views'), 'request' => t('Only show taxonomy filter control when taxonomy filter view is requested'), 'never' => t('Never show taxonomy filter control')));
  }
  $form['event_overview_options']['event_type_control'] = array('#type' => 'radios', '#title' => t('Content type filter controls'), '#default_value' => variable_get('event_type_control', 'all'), '#options' => array('all' => t('Show content type filter control on calendar views'), 'request' => t('Only show content type filter control when content type filter view is requested'), 'never' => t('Never show content type filter control')));

  return $form;
}

/**
 * @defgroup event_callback Functions which are the menu callbacks for this module
 */

/**
 * Displays a page containing event information.  The page layout defaults to a graphical calendar.
 *
 * @ingroup event_callback
 * @return the content for the event page.
 */
function event_page($year = NULL, $month = NULL, $day = NULL, $view = NULL, $types = NULL, $tids = NULL, $duration = NULL) {

  // get local timestamp value
  $now = _event_user_time();

  // create request timestamp and date values
  $stamp = gmmktime(0, 0, 0, ($month ? $month : gmdate('m', $now)), ($day ? $day : gmdate('d', $now)), ($year ? $year : gmdate('Y', $now)));
  $year = gmdate('Y', $stamp);
  $month = gmdate('m', $stamp);
  $day = gmdate('d', $stamp);

  $view = $view ? $view : variable_get('event_overview', 'month');

  if ($_POST['edit']['event_type_select']) {
    drupal_goto('event/'. $year .'/'. $month .'/'. $day .'/'. $view .'/'. $_POST['edit']['event_type_select'] .'/'. $tids);
  }

  if ($_POST['edit']['event_term_select']) {
    drupal_goto('event/'. $year .'/'. $month .'/'. $day .'/'. $view .'/'. ($types ? $types : 'all') .'/'. $_POST['edit']['event_term_select']);
  }

  $breadcrumbs[] = l(t('Home'), NULL);
  $breadcrumbs[] = l(t('Events'), 'event');
  $links = array();

  if ($types) {
    // The '+' character in a query string may be parsed as ' '.
    $types = preg_split('/[+ ]/', $types);
    foreach ($types as $type) {
      if (is_numeric($type)) {
        $ctype = module_invoke('flexinode', 'load_content_type', $type);
        if ($ctype->name) {
          $temp[$ctype->name] = 'flexinode-'. $type;
          $filter[] = $ctype->name;
        }
      }
      elseif (substr($type, 0, 10) == 'flexinode-') {
        $ctype = module_invoke('flexinode', 'load_content_type', substr($type, 10));
        if ($ctype->name) {
          $temp[$ctype->name] = $type;
          $filter[] = $ctype->name;
        }
      }
      elseif ($name = module_hook($type, 'node_name')) {
        $x = module_invoke($type, 'node_name', $node);
        $temp[$x] = $type;
        $filter[] = module_invoke($type, 'node_name', $node);
      }
    }

    if (is_array($filter)) {
      $links[] = l(t('view all'), 'event/'. $year .'/'. $month .'/'. $day .'/'. $view .'/');
      $title =  t('Filter') .': ' .implode(', ', $filter);
      $types = $temp;
    }
    else {
      $types = null;
    }
  }

  $terms = null;
  if ($tids && $tids != 'all') {
    $links[] = l(t('view all'), 'event/'.$year.'/'.$month.'/'.$day.'/day');
    if (preg_match('/^([0-9]+[+ ])+[0-9]+$/', $tids)) {
      // The '+' character in a query string may be parsed as ' '.
      $terms = preg_split('/[+ ]/', $tids);
    }
    else if (preg_match('/^([0-9]+,)*[0-9]+$/', $tids)) {
      $terms = explode(',', $tids);
    }
  }

  // add taxonomy filter controls to top of calendar
  if (variable_get('event_taxonomy_control', 'all') == 'all' || (variable_get('event_taxonomy_control', 'all') == 'request' && isset($terms))) {
    $output .= _event_get_taxonomy_control($terms);
  }
  // add content type filter controls to top of calendar
  if (variable_get('event_type_control', 'all') == 'all' || (variable_get('event_type_control', 'all') == 'request' && isset($types))) {
    $output .= _event_get_type_control($types);
  }

  switch ($view) {
    case 'day':
        // day view
        $headertitle = t('%weekday %month %day, %year', array('%weekday' => t(gmdate('l', $stamp)), '%month' => t(gmdate('F', $stamp)), '%day' => $day, '%year' => $year));
        $rows = event_calendar_day('page', $stamp, $types, $terms);
      break;
    case 'week':
        // week view
        // setup calendar table header
        $temp = $stamp - (_event_day_of_week($stamp) * (86400));
        $headertitle = t('Week of %month %day, %year', array('%month' => t(gmdate('F', $temp)), '%day' => gmdate('d', $temp), '%year' => $year));
        $colspan = 5;
        $rows = event_calendar_week('page', $stamp, $types, $terms);
      break;
    case 'month':
        // month view
        $headertitle = t('%month %year', array('%month' => t(gmdate('F', $stamp)), '%year' => $year));
        $colspan = 5;
        $rows = event_calendar_month('page', $stamp, $types, $terms);
      break;
    case 'table':
        // table view
        // next 30 day view, $duration can be set for different ranges
        // but set a maximum $duration of 1 year.
        $duration = $duration && $duration <= 366 ? $duration : variable_get('event_table_duration', '30');
        $endstamp = $stamp + ($duration * 86400);
        $headertitle = t('%startmonth %startdate, %startyear - %endmonth %enddate, %endyear', array('%startmonth' => t(gmdate('F', $stamp)), '%startdate' => gmdate('d', $stamp), '%startyear' => gmdate('Y', $stamp), '%endmonth' => t(gmdate('F', $endstamp)), '%enddate' => gmdate('d', $endstamp), '%endyear' => gmdate('Y', $endstamp)));
        $rows = event_calendar_table('page', $stamp, $endstamp, $types, $terms);
      break;
    case 'list':
        // list view
        // next 30 day view, $duration can be set for different ranges
        // but set a maximum $duration of 1 year.
        $duration = $duration && $duration <= 366 ? $duration : variable_get('event_table_duration', '30');
        $endstamp = $stamp + ($duration * 86400);
        $headertitle = t('%startmonth %startdate, %startyear - %endmonth %enddate, %endyear', array('%startmonth' => t(gmdate('F', $stamp)), '%startdate' => gmdate('d', $stamp), '%startyear' => gmdate('Y', $stamp), '%endmonth' => t(gmdate('F', $endstamp)), '%enddate' => gmdate('d', $endstamp), '%endyear' => gmdate('Y', $endstamp)));
        $rows = event_calendar_list('page', $stamp, $endstamp, $types, $terms);
      break;
    case 'feed':
        // rss feed
        drupal_set_header('Content-Type: text/xml; charset=utf-8');
        $duration = $duration ? $duration : variable_get('event_table_duration', '30');
        print event_calendar_rss($stamp, $duration, $types, $terms, $title);
      break;
    case 'ical':
        // ical feed
        drupal_set_header('Content-Type: text/calendar; charset=utf-8');
        drupal_set_header('Content-Disposition: attachment; filename="calendar.ics"; ');
        $duration = $duration ? $duration : variable_get('event_table_duration', '30');
        print event_calendar_ical($stamp, $duration, $types, $terms, $title);
      break;
  }

  if($view != 'feed' && $view != 'ical') {
    // build header navigation
    $prev = _event_nav($stamp, 'prev', $view, $types, $terms, $duration);
    $next = _event_nav($stamp, 'next', $view, $types, $terms, $duration);

    // setup calendar table header
    $header = array(
      array('class' => 'prev', 'data' => $prev),
      array('class' => 'heading', 'data' => $headertitle, 'colspan' => $colspan),
      array('class' => 'next', 'data' => $next));

    $node->day = $day;
    $node->month = $month;
    $node->year = $year;
    $node->filter = ($types ? implode('+', $types) : 'all') .'/'. ($terms ? implode('+', $terms) : 'all');

    $output .= theme('event_links', array_merge(module_invoke_all('link', 'event_'. $view, $node, FALSE), $links), $view);

    $output .= theme('event_calendar_'. $view, 'page', $header, $rows);
    $output .= theme('event_ical_link', 'event/ical/'. $node->filter);

    drupal_set_title(t('Events') . ($title ? ' - '. $title : ''));
    drupal_set_breadcrumb($breadcrumbs);
    print theme('page', $output);
  }
}

/**
 * Url wrapper function for static link to calendar by content type.
 *
 * @ingroup event_callback
 * @return redirect to the event page for calendar node type.
 */
function event_type($types = NULL, $view = NULL, $terms = NULL) {
  drupal_goto('event/'. format_date(_event_user_time(), 'custom', 'Y/m/d') .'/'. ($view ? $view : variable_get('event_overview', 'month')) .'/'. $types);
}

/**
 * Url wrapper function for static link to calendar by taxonomy terms.
 *
 * @ingroup event_callback
 * @return redirect to the event page for calendar taxonomy term.
 */
function event_term($filter = NULL, $view = NULL) {
  drupal_goto('event/'. format_date(_event_user_time(), 'custom', 'Y/m/d') .'/'. ($view ? $view : variable_get('event_overview', 'month')) .'/all/'. $filter);
}

/**
 * Url wrapper function for rss feeds
 *
 * @ingroup event_callback
 * @return redirect to the event rss feed page at current day
 */
function event_feed($types = 'all', $terms = 'all', $duration = NULL) {
  drupal_goto('event/'. format_date(_event_user_time(), 'custom', 'Y/m/d') .'/feed/'. $types .'/'. $terms .'/'. $duration);
}

/**
 * Url wrapper function for ical feeds
 *
 * @ingroup event_callback
 * @return redirect to the event ical feed page at current day
 */
function event_ical($types = 'all', $terms = 'all', $duration = NULL) {

  drupal_goto('event/'. format_date(_event_user_time(), 'custom', 'Y/m/d') .'/ical/'. $types .'/'. $terms .'/'. $duration);

  drupal_set_title(t('iCal support not enabled'));
  print theme('page', $output);
}

/**
 * @defgroup event_view Functions which handle the display of event nodes
 */

/**
 * Displays a monthly event calendar.
 *
 * @ingroup event_view
 * @return a themed monthly event calendar.
 */
function event_calendar_month($op, $stamp, $types = NULL, $terms = NULL) {

  $year = gmdate('Y', $stamp);
  $month = gmdate('m', $stamp);
  $day = gmdate('d', $stamp);

  switch ($op) {
    case 'page':
        // setup callback for data population
        $callback = 'event_render_day';
        $view = 'month';
      break;

    case 'block':
        // create navigation links
        $prev = _event_nav($stamp, 'prev', 'month', $types, $terms);
        $next = _event_nav($stamp, 'next', 'month', $types, $terms);

        $headertitle = l(t(gmdate('F', $stamp)) .' '. $year, 'event/'. $year .'/'. $month .'/'. $day .'/month');
        $header = array(
          array('class' => 'prev', 'data' => $prev),
          array('class' => 'heading', 'data' => $headertitle, 'colspan' => 5),
          array('class' => 'next', 'data' => $next));

        $callback = 'event_render_day_single';
        $view = 'block';
      break;
  }

  // get weekdays array and header information
  $weekdays = event_week_days();
  $rows[] = event_week_header();

  // get GMT current date value
  $today = _event_user_date();

  // name of the month
  $month_name = gmdate('M', $stamp);

  // timestamp of first day of month
  $curstamp = gmmktime(0, 0, 0, $month, 01, $year);

  // timestamp of last day in month
  $lastday = gmmktime(0, 0, 0, $month, gmdate('t', $stamp), $year);

  // pad the first week row array to fill up days in the previous month we don't build
  $row = array_fill(0, 6, '');
  // get the day of week offset value for the first day of the month
  $start = $offset = _event_day_of_week($curstamp);
  // render the month calendar
  while ($curstamp <= $lastday) {
    for ($x = $start; $x < 7; $x++) {
      $cur_day = (($week * 7) + ($x + 1) - $offset);
      $row[$x] = array(
        'class' => strtolower("$month_name ". $weekdays[$x]['day'] . ($curstamp == $today ? ' today' : '') . ($cur_day == $day ? ' selected' : '')),
        'id' => strtolower($month_name . $cur_day),
        'data' => $callback($year, $month, $cur_day, $view, $types, $terms));
      $curstamp += 86400;
      if ($curstamp > $lastday) {
        $x = 8;
      }
    }
    $week++;
    $start = 0;
    $rows[] = array_pad($row, 7, '&nbsp;');
    $row = array();
  }

  switch ($op) {
    case 'page':
        return $rows;
      break;
    case 'block':
        return theme("event_calendar_month", $op, $header, $rows);
      break;
  }
}

/**
 * Displays a weekly event calendar.
 *
 * @ingroup event_view
 * @return a themed weekly event calendar.
 */
function event_calendar_week($op, $stamp, $types = NULL, $terms = NULL) {
  // get weekdays array and header information
  $weekdays = event_week_days();
  $rows[] = event_week_header();

  // get GMT current date value
  $today = _event_user_date();

  // apply offset to goto first day of week
  $stamp -= (_event_day_of_week($stamp) * (86400));

  for ($x = 0; $x < 7; $x++) {
    $year = gmdate('Y', $stamp);
    $month = gmdate('m', $stamp);
    $cur_day = gmdate('j', $stamp);
    $month_name = gmdate('M', $stamp);

    $row[$x] = array(
      'class' => strtolower("$month_name ". $weekdays[$x]['day'] . ($stamp == $today ? ' today' : '') . ($cur_day == $day ? ' selected' : '')),
      'id' => strtolower($month_name . $cur_day),
      'data' => event_render_day($year, $month, $cur_day, 'week', $types, $terms));
    $stamp += 86400;
  }
  $rows[] = $row;
  return $rows;
}

/**
 * Displays a daily event calendar.
 *
 * @ingroup event_view
 * @return a themed daily event calendar.
 */
function event_calendar_day($op, $stamp, $types = NULL, $terms = NULL) {

  $today = _event_user_date();

  $year = gmdate('Y', $stamp);
  $month = gmdate('m', $stamp);
  $day = gmdate('j', $stamp);
  $dow = _event_day_of_week($stamp);
  $month_name = gmdate('M', $stamp);
  $weekdays = event_week_days();

  $rows[][] = array(
    'class' => strtolower("$month_name ". $weekdays[$dow]['day'] . ($stamp == $today ? ' today' : '')),
    'id' => strtolower($month_name . $day),
    'data' => event_render_day($year, $month, $day, 'day', $types, $terms),
    'colspan' => 3);

  return $rows;
}

/**
 * Creates a themed table of events.
 *
 * @ingroup event_view
 * @param $start The GMT starting date for the table.
 * @param $end The GMT ending date for the table.
 * @return A fully themed table.
 */
function event_calendar_table($op, $stamp, $endstamp, $types = NULL, $terms = NULL) {

  $today = _event_user_date();

  while ($stamp <= $endstamp) {
    $year = gmdate('Y', $stamp);
    $month = gmdate('m', $stamp);
    $cur_day = gmdate('j', $stamp);
    $month_name = gmdate('M', $stamp);
    $dow = _event_day_of_week($stamp);
    $weekdays = event_week_days();

    $rows[][] = array('colspan' => 3,
                      'class' => strtolower("$month_name ". $weekdays[$dow]['day'] . ($stamp == $today ? ' today' : '') . ($cur_day == $day ? ' selected' : '')),
                      'id' => strtolower($month_name . $cur_day),
                      'data' => event_render_day($year, $month, $cur_day, 'table', $types, $terms));
    $stamp += 86400;
  }

  return $rows;
}

/**
 * Creates a themed list of events.
 *
 * @ingroup event_view
 * @param $start The GMT starting date for the table.
 * @param $end The GMT ending date for the table.
 * @return A themed list of events.
 */
function event_calendar_list($op, $stamp, $endstamp, $types = NULL, $terms = NULL) {

  $today = _event_user_date();
  $rows = '';

  while ($stamp <= $endstamp) {
    $year = gmdate('Y', $stamp);
    $month = gmdate('m', $stamp);
    $cur_day = gmdate('j', $stamp);
    $month_name = gmdate('M', $stamp);
    $dow = _event_day_of_week($stamp);
    $weekdays = event_week_days();

    $rows .= event_render_day($year, $month, $cur_day, 'list', $types, $terms);
    $stamp += 86400;
  }

  return $rows;
}

/**
 * Creates an rss feed of events.
 *
 * @ingroup event_view
 * @param $stamp The GMT starting date for the feed.
 * @param $duration The number of days the feeds duration is.
 * @param $types The content types to filter the feed by.
 * @param $terms The taxonomy term tids to filter the feed by.
 * @param $title The filter title to append to the channel description.
 * @return A formatted rss feed.
 */
function event_calendar_rss($stamp, $duration, $types = NULL, $terms = NULL, $title = NULL) {
  global $base_url, $locale;

  $endstamp = $stamp + ($duration * 86400);
  $headertitle = t('%startmonth %startdate, %startyear - %endmonth %enddate, %endyear', array('%startmonth' => t(gmdate('F', $stamp)), '%startdate' => gmdate('d', $stamp), '%startyear' => gmdate('Y', $stamp), '%endmonth' => t(gmdate('F', $endstamp)), '%enddate' => gmdate('d', $endstamp), '%endyear' => gmdate('Y', $endstamp)));

  $result = db_query(db_rewrite_sql('SELECT n.nid, e.event_start FROM {event} e INNER JOIN {node} n ON n.nid = e.nid WHERE n.status = 1 AND ((e.event_start > %d AND e.event_start < %d) OR (e.event_end > %d AND e.event_end < %d) OR (e.event_start < %d AND e.event_end > %d)) ORDER BY event_start '), $stamp, $endstamp, $stamp, $endstamp, $stamp, $endstamp);

  $nodes = array();
  while ($nid = db_fetch_object($result)) {
    $node = node_load(array('nid' => $nid->nid));
    $nodes[] = $node;
  }

  $filtered = event_filter_nodes($nodes, $types, $terms);

  foreach($filtered as $node) {
    $body = '<div class="start">'. t('Start') .': '. $node->start_format .'</div>'."\n";
    $body .= '<div class="end">'. t('End') .': '. $node->end_format .'</div>'."\n";
    $body .= $node->teaser;
    $link = url("node/$node->nid", NULL, NULL, 1);
    // Allow modules to add additional item fields
    $extra = node_invoke_nodeapi($node, 'rss item');
    $extra = array_merge($extra, array(array('key' => 'pubDate', 'value' =>  date('r', $node->changed))));
    $items .= format_rss_item($node->title, $link, $body, $extra);
  }

  $description = $headertitle . ($title ? ' | '. $title : '');

  $output = "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n";
  $output .= "<!DOCTYPE rss [<!ENTITY % HTMLlat1 PUBLIC \"-//W3C//ENTITIES Latin 1 for XHTML//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml-lat1.ent\">]>\n";
  $output .= "<rss version=\"2.0\" xml:base=\"". $base_url ."\">\n";
  $output .= format_rss_channel(variable_get('site_name', 'drupal') . t(' - Events Feed'), $base_url . '/event/feed', $description, $items, $locale);
  $output .= "</rss>\n";

  return $output;
}

/**
 * Creates an ical feed of events.
 *
 * @ingroup event_view
 * @param $stamp The GMT starting date for the feed.
 * @param $duration The number of days the feeds duration is.
 * @param $types The content types to filter the feed by.
 * @param $terms The taxonomy term tids to filter the feed by.
 * @param $title The filter title to append to the channel description.
 * @return A formatted ical feed.
 */
function event_calendar_ical($stamp, $duration, $types = NULL, $terms = NULL, $title = NULL) {
  global $base_url, $locale;

  $endstamp = $stamp + ($duration * 86400);
  $headertitle = t('%startmonth %startdate, %startyear - %endmonth %enddate, %endyear', array('%startmonth' => t(gmdate('F', $stamp)), '%startdate' => gmdate('d', $stamp), '%startyear' => gmdate('Y', $stamp), '%endmonth' => t(gmdate('F', $endstamp)), '%enddate' => gmdate('d', $endstamp), '%endyear' => gmdate('Y', $endstamp)));

  $result = db_query(db_rewrite_sql('SELECT n.nid, e.event_start FROM {event} e INNER JOIN {node} n ON n.nid = e.nid WHERE n.status = 1 AND ((e.event_start > %d AND e.event_start < %d) OR (e.event_end > %d AND e.event_end < %d) OR (e.event_start < %d AND e.event_end > %d)) ORDER BY event_start '), $stamp, $endstamp, $stamp, $endstamp, $stamp, $endstamp);

  $events = array();
  while ($nid = db_fetch_object($result)) {
    $event = array();
    $node = node_load(array('nid' => $nid->nid));
    if (event_filter_node($node, $types, $terms)) {
      // Allow modules to affect item fields
      node_invoke_nodeapi($node, 'view', 'ical item');
      node_invoke_nodeapi($node, 'ical item');
      $event['start'] = $node->event_start;
      $event['end'] = $node->event_end;
      $event['location'] = $node->event_location;
      $event['summary'] = $node->title;
      $event['description'] = ($node->teaser ? $node->teaser : $node->body);
      $event['uid'] = url("node/$node->nid", NULL, NULL, 1);
      $event['url'] = url("node/$node->nid", NULL, NULL, 1);
      $events[] = $event;
    }
  }

  $description = $headertitle . ($title ? ' | '. $title : '');

  return ical_export($events, $description);
}

/**
 * Returns a calendar in the requested format, populated with the provided nodes.
 * This is not used internally, rather it is an API funciton for external modules
 * to use for rendering calendars when constructing thier own event objects.
 *
 * @ingroup event_view
 *
 * @param $view - The format of calendar to return. Possible values:
 *                "table": A tabular calendar.
 *                "month": A month calendar.
 *                "week": A week calendar.
 *                "day": A day calendar.
 *  @param $nodes â€“ An associative array of nodes with nids for key values.
 *           Node objects must have GMT timestamp values for start ($node->event_start).
 *           Optionally, an end value ($node->event_end) and a time zone offset value
 *           in the same format as drupal core ($node->tz). If a node has no end
 *           value, it is rendered on only one day. If no time zone value is displayed
 *           the time is rendered with no time zone offset (GMT).
 *  @param $module - String containing the name of the module calling the function
 *  @param $title - A string value that will be printed into the header of the calendar
 *  @return Themed calendar view of nodes
 */
function event_get_calendar($view, $nodes, $module, $title = NULL) {
  $today = _event_user_date();

  foreach ($nodes as $node) {
    $node->event_links = module_invoke_all('link', 'event_node_'. $view, $node, FALSE);
    $nodes[$node->nid] = $node;
    $nid->nid = $node->nid;

    // $node_start and $node_end are local timestamp values
    $node_start = gmmktime(0, 0, 0, _event_date('m', $node->event_start, $node->start_offset), _event_date('d', $node->event_start, $node->start_offset), _event_date('Y', $node->event_start, $node->start_offset));
    if ($node->event_end) {
      $node_end = gmmktime(0, 0, 0, _event_date('m', $node->event_end, $node->end_offset), _event_date('d', $node->event_end, $node->end_offset), _event_date('Y', $node->event_end, $node->end_offset));
    }
    else {
      $node_end = $node_start;
    }

    if ($node_start == $node_end) {
      $nid->event_state = 'singleday';
      $nid->stamp = $node_start;
      $data[gmdate('Y', $node_start)][gmdate('m', $node_start)][gmdate('j', $node_start)][] = $nid;
    }
    else {
      // roll through each day the event occurs and set an entry for each
      for ($x = $node_start; $x <= $node_end; $x += 86400) {
        if ($x == $node_end) {
          $nid->event_state = 'end';
          $nid->stamp = $x;
          $data[gmdate('Y', $x)][gmdate('m', $x)][gmdate('j', $x)][] = $nid;
        }
        elseif ($x == $node_start) {
          $nid->event_state = 'start';
          $nid->stamp = $x;
          $data[gmdate('Y', $x)][gmdate('m', $x)][gmdate('j', $x)][] = $nid;
        }
        else {
          $nid->event_state = 'ongoing';
          $nid->stamp = $x;
          $data[gmdate('Y', $x)][gmdate('m', $x)][gmdate('j', $x)][] = $nid;
        }
      }
    }
  }

  // order the years, months and days
  ksort($data, SORT_NUMERIC);
  foreach($data as $year => $months) {
    ksort($data[$year], SORT_NUMERIC);
    foreach($data[$year] as $month => $days) {
      ksort($data[$year][$month], SORT_NUMERIC);
    }
  }

  $weekdays = event_week_days();
  switch ($view) {
    case 'day':
    case 'table':
        foreach ($data as $year => $months) {
          if(count($data) > 1) {
            // add year heading
            $rows[][] = array(
                        'class' => 'heading year',
                        'id' => 'year'.$year,
                        'data' => $year);
          }
          foreach($months as $month => $days) {
            foreach($days as $day => $nids) {
              $content = theme('event_calendar_date_box', $year, $month, $day, 'table');
              foreach($nids as $nid) {
                if(!$month_name) {
                  $month_name = gmdate('M', $nid->stamp);
                  $dow = _event_day_of_week($nid->stamp);
                }
                $node = $nodes[$nid->nid];

                $node->event_state = $nid->event_state;
                if($output = module_invoke($module, 'event_node_'. $view, $node)) {
                  $content .= $output;
                }
                else {
                  $content .= theme('event_node_'. $view, $node);
                }
              }
              $rows[][] = array(
                'class' => strtolower("$month_name ". $weekdays[$dow]['day'] . ($nid->stamp == $today ? ' today' : '')),
                'id' => strtolower($month_name . $day),
                'data' => $content);
              $month_name = NULL;
            }
          }
        }
      break;

    case 'week':
    case 'month':
        $colspan = '7';
        foreach ($data as $year => $months) {
          if(count($data) > 1) {
            // add year heading
            $rows[][] = array(
                        'class' => 'heading year',
                        'id' => 'year'. $year,
                        'data' => $year,
                        'colspan' => $colspan);
          }
          foreach ($months as $month => $days) {
            // timestamp of first day in month
            $curstamp = gmmktime(0, 0, 0, $month, 1, $year);
            // timestamp of last day in month
            $lastday = gmmktime(0, 0, 0, $month, gmdate('t', $curstamp), $year);
            // pad the first week row array to fill up days in the previous month we don't build
            $row = array_fill(0, 6, '');
            // get the day of week offset value for the first day of the month
            $start = $offset = _event_day_of_week($curstamp);
            // get name of month
            $month_name = gmdate('M', $curstamp);
            // set week counter
            $week = 0;
            // add month header
            $rows[][] = array(
                        'class' => 'heading month',
                        'id' => 'month'. $month,
                        'data' => $month_name,
                        'colspan' => $colspan);
            $rows[] = event_week_header();

            while ($curstamp <= $lastday) {
              for ($x = $start; $x < 7; $x++) {
                $cur_day = (($week * 7) + ($x + 1) - $offset);

                $content = theme('event_calendar_date_box', $year, $month, $cur_day, $view);

                // render nodes for the day
                if(is_array($days[$cur_day])) {
                  foreach($days[$cur_day] as $nid) {
                    $node = $nodes[$nid->nid];
                    $node->event_state = $nid->event_state;
                    if($output = module_invoke($module, 'event_node_'. $view, $node)) {
                      $content .= $output;
                    }
                    else {
                      $content .= theme('event_node_'. $view, $node);
                    }
                  }
                }

                $row[$x] = array(
                  'class' => strtolower("$month_name ". $weekdays[$x]['day'] . ($curstamp == $today ? ' today' : '')),
                  'id' => strtolower($month_name . $day),
                  'data' => $content);

                $curstamp += 86400;
                if ($curstamp > $lastday) {
                  $x = 8;
                }
              }
              $week++;
              $start = 0;
              $rows[] = array_pad($row, 7, '&nbsp;');
              $row = array();
            }
          }
        }
      break;
  }

  $header[] = ($title ? array('class' => 'heading', 'data' => $title, 'colspan' => $colspan) : array());
  return theme('event_calendar_'. $view, 'page', $header, $rows);
}

/**
 * @defgroup event_support Functions that support the event system
 */


/**
 * Returns an array of nodes that occur on a given date.
 * Handles content type and taxonomy filters.
 *
 * @ingroup event_support
 * @param $year The year the event is taking place.
 * @param $month The month the event is taking place.
 * @param $day The day the event is taking place. No leading zeroes.
 * @return An array containing all of the events taking place on the specified date, or an empty array if none exist.
 */
function event_calendar_data($year, $month, $day, $view = NULL, $types = NULL, $terms = NULL) {
  static $data;
  global $user;

  $day_start = _event_mktime(0, 0, 0, $month, $day, $year);

  if (!is_array($data[$year][$month])) {
    $data[$year][$month] = array();

    //call the event_load function in all modules
    module_invoke_all('event_load', $year, $month, $day, $view, $types, $terms);

    // get GMT values from local date values for db query
    $first = _event_mktime(0, 0, 0, $month, 1, $year);
    $last = _event_mktime(23, 59, 59, $month + 1, 0, $year);

    $result = db_query(db_rewrite_sql('SELECT n.nid, e.event_start FROM {event} e INNER JOIN {node} n ON n.nid = e.nid WHERE n.status = 1 AND ((e.event_start > %d AND e.event_start < %d) OR (e.event_end > %d AND e.event_end < %d) OR (e.event_start < %d AND e.event_end > %d)) ORDER BY event_start '), $first, $last, $first, $last, $first, $last);

    while ($nid = db_fetch_object($result)) {
      $node = node_load(array('nid' => $nid->nid));

      // we have to load these here since there is no way to pass the $view parameter to nodeapi through node_load :/
      $node->event_links = module_invoke_all('link', 'event_node_'. $view, $node, FALSE);

      // this array contains the loaded nodes for the month, so we dont have them stored for every day they occur
      $data[$year][$month]['nodes'][$nid->nid] = $node;

      $node_start = gmmktime(0, 0, 0, _event_date('m', $node->event_start, $node->start_offset), _event_date('d', $node->event_start, $node->start_offset), _event_date('Y', $node->event_start, $node->start_offset));
      $node_end = gmmktime(0, 0, 0, _event_date('m', $node->event_end, $node->end_offset), _event_date('d', $node->event_end, $node->end_offset), _event_date('Y', $node->event_end, $node->end_offset));

      if (($node_start == $node_end) && (gmdate('m', $node_start) == $month)) {
        $nid->event_state = 'singleday';
        $data[$year][$month][gmdate('j', $node_start)][] = $nid;
      }
      else {
        // because $first is a local timestamp we compensate for the tz offset here so we dont have to do repetitive day value comparisons below
        $first -= ($first % 86400);
        // roll through each day the event occurs and set an entry for each
        for ($x = ($first > $node_start ? $first : $node_start); $x < $last; $x += 86400) {
          if (gmdate('m', $x) == $month) {
            if ($x == $node_end) {
              $nid->event_state = 'end';
              $data[$year][$month][gmdate('j', $x)][] = $nid;
              $x = $last + 1;
            }
            elseif ($x == $node_start) {
              $nid->event_state = 'start';
              $data[$year][$month][gmdate('j', $x)][] = $nid;
            }
            else {
              $nid->event_state = 'ongoing';
              $data[$year][$month][gmdate('j', $x)][] = $nid;
            }
          }
        }
      }
    }
  }

  $nodes = array();
  $event_types = event_get_types();
  if ($data[$year][$month][$day]) {
    if (isset($types)) {
      // content type filters set
      if (isset($terms)) {
        // taxonomy and content type filters set
        foreach ($data[$year][$month][$day] as $nid) {
          $node = $data[$year][$month]['nodes'][$nid->nid];
          if (in_array($node->type, $types) && event_taxonomy_filter($node, $terms)) {
            // this node is the content type and taxonomy term requested
            if (count($types) == 1 && in_array($node->type, $event_types['solo'])) {
              // only display solo types if there is only one event type requested
              $node->event_current_date = $day_start;
              $node->event_state = $nid->event_state;
              $nodes[] = $node;
            }
            elseif (in_array($node->type, $event_types['all'])) {
              $node->event_current_date = $day_start;
              $node->event_state = $nid->event_state;
              $nodes[] = $node;
            }
          }
        }
      }
      else {
        // only content type filters
        foreach ($data[$year][$month][$day] as $nid) {
          $node = $data[$year][$month]['nodes'][$nid->nid];
          if (in_array($node->type, $types)) {
            if (count($types) == 1 && in_array($node->type, $event_types['solo'])) {
              // only display solo types if there is only one event type requested
              $node->event_current_date = $day_start;
              $node->event_state = $nid->event_state;
              $nodes[] = $node;
            }
            elseif (in_array($node->type, $event_types['all'])) {
              $node->event_current_date = $day_start;
              $node->event_state = $nid->event_state;
              $nodes[] = $node;
            }
          }
        }
      }
    }
    elseif (isset($terms)) {
      // no types, only taxonomy filters
      foreach ($data[$year][$month][$day] as $nid) {
        $node = $data[$year][$month]['nodes'][$nid->nid];
        if (event_taxonomy_filter($node, $terms) && in_array($node->type, $event_types['all'])) {
          $node->event_current_date = $day_start;
          $node->event_state = $nid->event_state;
          $nodes[] = $node;
        }
      }
    }
    else {
      foreach ($data[$year][$month][$day] as $nid) {
        // no filters set, only show events with content types states of 'all'
        $node = $data[$year][$month]['nodes'][$nid->nid];
        if (in_array($node->type, $event_types['all'])) {
          $node->event_current_date = $day_start;
          $node->event_state = $nid->event_state;
          $nodes[] = $node;
        }
      }
    }
  }

  return $nodes;
}

function event_filter_node($node, $types, $terms) {
  $event_types = event_get_types();

  if (isset($types)) {
    // content type filters set
    if (isset($terms)) {
      // taxonomy and content type filters set
      if (in_array($node->type, $types) && event_taxonomy_filter($node, $terms)) {
        // this node is the content type and taxonomy term requested
        if (count($types) == 1 && in_array($node->type, $event_types['solo'])) {
          // only display solo types if there is only one event type requested
          return TRUE;
        }
        elseif (in_array($node->type, $event_types['all'])) {
          return TRUE;
        }
      }
    }
    else {
      // only content type filters
      if (in_array($node->type, $types)) {
        if (count($types) == 1 && in_array($node->type, $event_types['solo'])) {
          // only display solo types if there is only one event type requested
          return TRUE;
        }
        elseif (in_array($node->type, $event_types['all'])) {
          return TRUE;
        }
      }
    }
  }
  elseif (isset($terms)) {
    // no types, only taxonomy filters
    if (event_taxonomy_filter($node, $terms) && in_array($node->type, $event_types['all'])) {
      return TRUE;
    }
  }
  else {
    // no filters set, only show events with content types states of 'all'
    if (in_array($node->type, $event_types['all'])) {
      RETURN TRUE;
    }
  }
  return FALSE;
}

function event_filter_nodes($nodes, $types, $terms) {
  $event_types = event_get_types();

  $results = array();
  if (isset($types)) {
    // content type filters set
    if (isset($terms)) {
      // taxonomy and content type filters set
      foreach ($nodes as $node) {
        if (in_array($node->type, $types) && event_taxonomy_filter($node, $terms)) {
          // this node is the content type and taxonomy term requested
          if (count($types) == 1 && in_array($node->type, $event_types['solo'])) {
            // only display solo types if there is only one event type requested
            $results[] = $node;
          }
          elseif (in_array($node->type, $event_types['all'])) {
            $results[] = $node;
          }
        }
      }
    }
    else {
      // only content type filters
      foreach ($nodes as $node) {
        if (in_array($node->type, $types)) {
          if (count($types) == 1 && in_array($node->type, $event_types['solo'])) {
            // only display solo types if there is only one event type requested
            $results[] = $node;
          }
          elseif (in_array($node->type, $event_types['all'])) {
            $results[] = $node;
          }
        }
      }
    }
  }
  elseif (isset($terms)) {
    // no types, only taxonomy filters
    foreach ($nodes as $node) {
      if (event_taxonomy_filter($node, $terms) && in_array($node->type, $event_types['all'])) {
        $results[] = $node;
      }
    }
  }
  else {
    // no filters set, only show events with content types states of 'all'
    foreach ($nodes as $node) {
      if (in_array($node->type, $event_types['all'])) {
        return $nodes;
      }
    }
  }
  return $results;
}

function event_taxonomy_filter($node, $terms) {
  if ($tids = taxonomy_node_get_terms($node->nid)) {
    foreach ($tids as $tid => $term) {
      if (in_array($tid, $terms)) {
        return TRUE;
      }
    }
  }
  return FALSE;
}

/**
 * Returns a link to the event page for a single day.
 *
 * @ingroup event_support
 * @param $year The year the event is taking place.
 * @param $month The month the event is taking place.
 * @param $day The day the event is taking place. No leading zeroes
 * @return The value of the day requested. If the day has events, the value will be a link to a more detailed page of that day's events.
 */
function event_render_day_single($year, $month, $day, $view, $types, $terms) {
  return count(event_calendar_data($year, $month, $day)) ? l($day, "event/$year/$month/$day/day") : $day;
}

/**
 * Returns an day of events for a calendar.
 *
 * @ingroup event_support
 * @param $year The year the event is taking place.
 * @param $month The month the event is taking place.
 * @param $day The day the event is taking place. No leading zeroes.
 * @return A string containing all of the events taking place.
 */
function event_render_day($year, $month, $day, $view, $types, $terms) {

  $nodes = event_calendar_data($year, $month, $day, $view, $types, $terms);

  if (count($nodes)) {
    $output = theme('event_calendar_date_box', $year, $month, $day, $view);
    foreach ($nodes as $node) {
      $output .= theme('event_node_'. $view, $node);
    }
  }
  else {
    $output .= theme('event_empty_day', $year, $month, $day, $view);
  }

  return $output;
}

/**
 * Returns week day names and thier translated values, corrected for the start of week day settings (mon or sun)
 *
 * @ingroup event_support
 * @return an associative array containing weekday names
 */
function event_week_days() {
  static $weekdays;

  if (!$weekdays) {
    if (variable_get('date_first_day', 1)) {
      $weekdays = array(array('day' => 'Mon', 't' => t('Mon')), array('day' => 'Tue', 't' => t('Tue')), array('day' => 'Wed', 't' => t('Wed')), array('day' => 'Thu', 't' => t('Thu')), array('day' => 'Fri', 't' => t('Fri')), array('day' => 'Sat', 't' => t('Sat')), array('day' => 'Sun', 't' => t('Sun')));
    }
    else {
      $weekdays = array(array('day' => 'Sun', 't' => t('Sun')), array('day' => 'Mon', 't' => t('Mon')), array('day' => 'Tue', 't' => t('Tue')), array('day' => 'Wed', 't' => t('Wed')), array('day' => 'Thu', 't' => t('Thu')), array('day' => 'Fri', 't' => t('Fri')), array('day' => 'Sat', 't' => t('Sat')));
    }
  }
  return $weekdays;
}

/**
 * Formats the weekday information into table header format
 *
 * @ingroup event_support
 * @return array with weekday table header data
 */
function event_week_header() {
  // create week header
  $days = event_week_days();

  foreach ($days as $day) {
    $row[] = array('class' => strtolower("days ". $day['day']), 'data' => $day['t']);
  }

  return $row;
}

/**
 * Formats a GMT timestamp to local date values using time zone offset supplied.
 * All timestamp values in event nodes are GMT and translated for display here.
 *
 * Time zone settings are applied in the following order
 * 1. If supplied, time zone offset is applied
 * 2. If user time zones are enabled, user time zone offset is applied
 * 3. If neither 1 nor 2 apply, the site time zone offset is applied
 *
 * @param $format The date() format to apply to the timestamp.
 * @param $timestamp The GMT timestamp value.
 * @param $offset Time zone offset to apply to the timestamp.
 * @ingroup event_support
 * @return gmdate() formatted date value
 */
function _event_date($format, $timestamp, $offset = null) {
  global $user;

  if (isset($offset)) {
    $timestamp += $offset;
  }
  elseif (variable_get('configurable_timezones', 1) && $user->uid && strlen($user->timezone)) {
    $timestamp += $user->timezone;
  }
  else {
    $timestamp += variable_get('date_default_timezone', 0);
  }

  // make sure we apply the site first day of the week setting for dow requests
  if ($format == 'w') {
    $result = _event_day_of_week($timestamp);
  }
  else {
    $result = gmdate($format, $timestamp);
  }
  return  $result;
}

// return the day of week with start of week offset applied
function _event_day_of_week($stamp) {
  $dow = gmdate('w', $stamp);
  $dow = (variable_get('date_first_day', 1) ? ($dow == 0 ? 6 : --$dow ) : $dow);
  return $dow;
}

/**
 * Formats local time values to GMT timestamp using time zone offset supplied.
 * All time values in the database are GMT and translated here prior to insertion.
 *
 * Time zone settings are applied in the following order:
 * 1. If supplied, time zone offset is applied
 * 2. If user time zones are enabled, user time zone offset is applied
 * 3. If neither 1 nor 2 apply, the site time zone offset is applied
 *
 * @param $format The date() format to apply to the timestamp.
 * @param $timestamp The GMT timestamp value.
 * @param $offset Time zone offset to apply to the timestamp.
 * @ingroup event_support
 * @return gmdate() formatted date value
 */
function _event_mktime($hour, $minute, $second, $month, $day, $year, $offset = NULL) {
  global $user;
  $timestamp = gmmktime($hour, $minute, $second, $month, $day, $year);
  if (isset($offset)) {
    return $timestamp - $offset;
  }
  elseif (variable_get('configurable_timezones', 1) && $user->uid && strlen($user->timezone) && (variable_get('event_timezone_display', 'event') == 'user')) {
    return $timestamp - $user->timezone;
  }
  else {
    return $timestamp - variable_get('date_default_timezone', 0);
  }
}

// returns a local timestamp based on the user or site time zone
function _event_user_time() {
  global $user;

  if (variable_get('configurable_timezones', 1) && $user->uid && strlen($user->timezone)) {
    return (time() - date("Z")) + $user->timezone;
  }
  else {
    return (time() - date("Z")) + variable_get('date_default_timezone', 0);
  }
}

// returns a local timestamp value corrected with the user or site time zone with time information set to 0
function _event_user_date() {
  static $date;
  if (!$date) {
    $now = _event_user_time();
    $date = gmmktime(0, 0, 0, gmdate('m', $now), gmdate('j', $now), gmdate('Y', $now));
  }
  return $date;
}

/**
 * Constructs the time select boxes.
 *
 * @ingroup event_support
 * @param $timestamp The time already selected.  This is applicable if the user is editing an event.
 * @param $prefix The value to prepend to the select element names, used for start and end times.
 * @return A set of select boxes that contain options for month, day, year, hour, and minute
 */
function event_form_date($timestamp, $prefix = 'start', $offset) {
  //determine settings for form's hour selector
  if (variable_get('event_ampm', '0')) {
    $hour_format = t('g');
    $first_hour = 1;
    $last_hour = 12;
  }
  else {
    $hour_format = t('H');
    $first_hour = 0;
    $last_hour = 23;
  }

  $date = getdate(gmmktime());
  $curyear = $date['year'];
  while ($i < 10) {
    $years[$curyear + $i] = $curyear + $i;
    $i++;
  }

  $months = array(1 => t('January'), t('February'), t('March'), t('April'), t('May'), t('June'), t('July'), t('August'), t('September'), t('October'), t('November'), t('December'));
  for ($i = 1; $i <= 31; $i++) $days[$i] = $i;
  for ($i = $first_hour; $i <= $last_hour; $i++) $hours[$i] = $i;
  for ($i = 0; $i <= 59; $i++) $minutes[$i] = $i < 10 ? "0$i" : $i;
  $am_pms = array('am' => t('am'), 'pm' => t('pm'));

  // This is a GMT timestamp, so we use our wrapper _event_date() to display values.
  $year = _event_date('Y', $timestamp, $offset);
  $month = _event_date('m', $timestamp, $offset);
  $day = _event_date('d', $timestamp, $offset);
  $hour = _event_date($hour_format, $timestamp, $offset);
  $minute = _event_date('i', $timestamp, $offset);
  $am_pm = _event_date('a', $timestamp, $offset);

  $form[$prefix .'_day'] = array('#prefix' => '<div class="container-inline"><div class="day">', '#type' => 'textfield', '#default_value' => $day, '#maxlength' => 2, '#size' => 2, '#description' => t('day'), '#required' => TRUE);
  $form[$prefix .'_month'] = array('#type' => 'select', '#default_value' => $month, '#options' => $months, '#description' => t('month'), '#required' => TRUE);
  $form[$prefix .'_year'] = array('#type' => 'textfield', '#default_value' => $year, '#maxlength' => 4, '#size' => 4, '#description' => t('year'), '#required' => TRUE);
  $form[$prefix .'_hour'] = array('#prefix' => '</div><div class="time">', '#type' => 'select', '#default_value' => $hour, '#options' => $hours, '#required' => TRUE, '#description' => t('hour'));
  $form[$prefix .'_minute'] = array('#prefix' => ':', '#type' => 'select', '#default_value' => $minute, '#options' => $minutes, '#required' => TRUE, '#description' => t('minutes'));
  if (variable_get('event_ampm', '0')) {
    $form[$prefix .'_ampm'] = array('#type' => 'radios', '#default_value' => $am_pm, '#options' => $am_pms, '#required' => TRUE);
  }
  $form[$prefix .'_close'] = array('#type' => 'markup', '#suffix' => '</div></div>');

  return $form;
}

/**
 * Validates the start and end times in a node form submission.
 * - Changes 24 hour time to 12 hour time (if the module is configured to do this).
 *  - Adjusts times for time zone offsets.
 *
 * @ingroup event_support
 * @param $node The submitted node with form data.
 * @param $prefix The prefix to validate and set (start or end).
 */
function event_validate_form_date(&$node, $pre = '') {

  if ($pre != '') {
    $prefix = $pre .'_';
  }

  // Re-calculate $node->event_start if we have all the parameters.
  if (isset($node->{$prefix . 'year'}) && isset($node->{$prefix . 'month'}) && isset($node->{$prefix . 'day'}) && isset($node->{$prefix . 'hour'}) && isset($node->{$prefix . 'minute'})) {
    $hour = $node->{$prefix . 'hour'};
    if (variable_get('event_ampm', '0')) {
      if (($node->{$prefix . 'ampm'} == 'pm') && ($hour != 12)) {
        $hour += 12;
      }
      elseif (($node->{$prefix . 'ampm'} == 'am') && ($hour == 12)) {
        $hour -= 12;
      }
    }
    // translate the input values to GMT and set the node property value
    $offset = event_get_offset($node->timezone, gmmktime($hour, $node->{$prefix . 'minute'}, 0, $node->{$prefix . 'month'}, $node->{$prefix . 'day'}, $node->{$prefix . 'year'}));
    $node->{'event_'. $pre} = _event_mktime($hour, $node->{$prefix . 'minute'}, 0, $node->{$prefix . 'month'}, $node->{$prefix . 'day'}, $node->{$prefix . 'year'}, $offset);
  }
  elseif (!$node->$prefix) {
    // Round to nearest hour:
    $now = _event_user_time();
    $node->$prefix = $now - ($now % (60 * 60));
  }
}

/**
 * Build the navigation links for the calendar views
 *
 * @ingroup event_support
 * @param $date The GMT date we are viewing
 * @param $dir The 'direction' we want (prev or next)
 * @param $view The view we are navigating, month, week, day or table
 * @param $types The content types to filter by
 * @param $terms The taxonomy terms to filter by
 * @param $duration The duration of the current view in multiples of view type
 * @return Themed navigation link.
 */
function _event_nav($date, $dir, $view, $types, $terms, $duration = NULL) {

  // first, retrieve the stored timestamp of the first/last event
  $range = variable_get('event_range_'. $dir, -1);
  // If the variable isn't set, set it and try again
  if ($range == -1) {
    event_set_range();
    $range = variable_get('event_range_'. $dir, $date);
  }

  // if we are beyond the range of the stored events, dont display navigation
  if (($dir == 'prev' && $range < $date) || ($dir == 'next' && $range > $date)) {
    $inc = ($dir == 'prev' ? -1 : 1);
    $duration = ($duration ? $duration : 1);

    switch ($view) {
      case 'day':
      case 'table':
          // Increment by $duration*days
          $date += ($inc * ($duration * 86400));
        break;
      case 'week':
          // Increment by $duration*weeks
          $date += ($inc * ($duration * (86400 * 7)));
        break;
      case 'month':
          // Increment by $duration*months
          $date = gmmktime(0, 0, 0, gmdate('m', $date) + ($duration * $inc), gmdate('j', $date), gmdate('Y', $date));
        break;
    }

    $url[] = 'event';
    $url[] = gmdate('Y', $date);
    $url[] = gmdate('m', $date);
    $url[] = gmdate('d', $date);
    $url[] = $view;
    $url[] = ($types ? implode('+', $types) : 'all');
    $url[] = ($terms ? implode('+', $terms) : 'all');
    $url[] = $duration;
    return theme('event_nav_'. $dir, implode('/', $url));
  }
}

/**
* Returns a dropdown event taxonomy term input control.
*
* @ingroup event_support.
* @param $curterm The current term id.
* @param $submit Adds 'onChange' form submit javascript command to control.
* @return A form with a dropdown event taxonomy term input control.
*/
function _event_get_taxonomy_control($curterm = NULL, $autosubmit = TRUE) {
  if (module_exist('taxonomy')) {
    $types = event_get_types();
    $vs = array();
    foreach ($types['all'] as $type) {
      $results = taxonomy_get_vocabularies($type);
      foreach ($results as $vocab) {
        $vs[$vocab->vid] = $vocab;
      }
    }

    $results = null;
    foreach ($types['solo'] as $type) {
      $results = taxonomy_get_vocabularies($type);
      foreach ($results as $vocab) {
        $vs[$vocab->vid] = $vocab;
      }
    }

    $items['all'] = t('(all)');
    foreach ($vs as $vid => $vocab) {
      $tree = taxonomy_get_tree($vid);
      foreach ($tree as $term) {
        $items[$term->tid] = $vocab->name.' - '.$term->name;
      }
    }

    $form['event_term_select'] = array('#type' => 'select', '#default_value' => $curterm, '#options' => $items, '#description' => t('Select event terms to filter by'), '#attributes' => ($autosubmit ? 'onChange="this.form.submit()"' : ''));

    $form = drupal_get_form('event_taxonomy_filter', $form);

    return theme('event_filter_control', $form);
  }
}

/**
* Returns a dropdown event-enabled content type input control.
*
* @ingroup event_support.
* @param $tid The current term id.
* @param $submit Adds 'onChange' form submit javascript command to control.
* @return A form with a dropdown event taxonomy term input control.
*/
function _event_get_type_control($curtype = NULL, $autosubmit = TRUE) {
  if (module_exist('taxonomy')) {
    $results = event_get_types('all');

    $items['all'] = t('(all)');
    foreach ($results as $type) {
      if (module_hook($type, 'node_name')) {
        $items[$type] = module_invoke($type, 'node_name', $node);
      }
      elseif ($ctype = module_invoke('flexinode', 'load_content_type', substr($type, 10))) {
        $items[$type] = $ctype->name;
      }
    }

    $form['event_type_select'] = array('#type' => 'select', '#default_value' => $curtype, '#options' => $items, '#description' => t('Select event type to filter by'), '#attributes' => ($autosubmit ? 'onChange="this.form.submit()"' : ''));

    $form = drupal_get_form('event_type_filter', $form);

    return theme('event_filter_control', $form);
  }
}

/**
 * @defgroup event_block Functions for event blocks.
 */

/**
 * Provides the blocks that this module is capable of displaying.
 *
 * @ingroup event_block
 * @param $op the operation that is being requested.  This defaults to 'list', which indicates that the method should
 *        return which blocks are available.
 * @param $delta the specific block to display.  This is actually the offset into an array.
 * @return one of two possibilities.  The first is an array of available blocks.  The other is an array containing a
 *        block.
 */
function event_block($op = 'list', $delta = 0) {
  switch ($op) {
    case 'list' :
      $blocks[0]['info'] = t('Calendar to browse events.');
      $blocks[1]['info'] = t('List of upcoming events.');
      return $blocks;
      break;
    case 'view' :
      if (user_access('access content')) {
        switch ($delta) {
          case 0:
            $time = _event_user_date();
            if (arg(0) == 'event' && is_numeric(arg(1))) {
              // follow event calendar
              $year = (arg(1) ? arg(1) : gmdate('Y', $time));
              $month = (arg(2) ? arg(2) : gmdate('m', $time));
              $day = (arg(3) ? arg(3) : gmdate('d', $time));
              $stamp = gmmktime(0, 0, 0, $month, $day, $year);
            }
            else {
              $stamp = _event_user_date();
            }
            $block['subject'] = t('Events');
            $block['content'] = event_calendar_month('block', $stamp);
            return $block;
          case 1:
            $block['subject'] = t('Upcoming events');
            $block['content'] = event_block_upcoming(variable_get('event_upcoming_limit', '6'));
            return $block;
        }
      }
      break;
  }
}

/**
* Creates a block that contains upcoming events.
*
* @ingroup event_block
* @param $limit The number of events that can be displayed in the block.
* @return A string containing the fully themed block.
*/
function event_block_upcoming($limit = 6) {
  global $user;
  // For two hours, we display "NOW"
  $time = time() - (2 * 60 * 60);
  $result = db_query(db_rewrite_sql("SELECT n.nid, n.title, n.type, n.status, n.moderate, e.event_start FROM {node} n INNER JOIN {event} e USING (nid) WHERE n.status = 1 AND n.moderate = 0 AND e.event_start >= %d ORDER BY event_start"), $time);

  while (($node = db_fetch_object($result)) && $limit) {

    //call the event_edit_upcoming hook in all modules.  note that modules can prevent display of a node by setting
    //it's status to 0 here.
    foreach (module_implements('event_edit_upcoming') as $module) {
      $function = $module .'_event_edit_upcoming';
      $function($node);
    }
    $minutesleft = floor(($node->event_start - time()) / 60);

    if ($minutesleft < 0) {
      $timeleft = t('NOW');
    }
    else if ($minutesleft < 60) {
      $timeleft = format_plural($minutesleft, '1 minute', '%count minutes');
    }
    else if ($minutesleft >= 60 && $minutesleft < (24 * 60)) {
      $timeleft = format_plural(floor($minutesleft / 60), '1 hour', '%count hours');
    }
    else if ($minutesleft >= (24 * 60)) {
      $days = floor($minutesleft / (24 * 60));
      // hours remainder
      $hours = ($minutesleft % (24 * 60)) / 60;
      // hours left in the day
      $hours_left = ((time() / 60) % (24 * 60)) / 60;
      // see if the remainder of hours on the event date is greater than the hours left in today, if so increase the days by one so that the days remaining mimics the date rather than how many 24 hour periods there are between now and then.
      if ($hours>$hours_left) {
        $days++;
      }
      $timeleft = format_plural($days, '1 day', '%count days');
    }

    $node->timeleft = $timeleft;
    $ctype = module_invoke('flexinode', 'load_content_type', substr($node->type, 10));
    $node->typename = ($ctype->name ? $ctype->name : $node->type);

    if ($node->status) {
      $items[] = theme('event_upcoming_item', $node);
      $limit--;
    }
  }
  if(!$items) {
    $items[] = t('no upcoming events available');
  }

  $output = theme("event_upcoming_block", $items);
  $output .= theme('event_ical_link', 'event/ical');
  $output .= theme('event_more_link', 'event');

  return $output;
}

/**
 * @defgroup event_nodeapi Functions for nodeapi integration
 */

function event_form_alter($form_id, &$form) {
  if (isset($form['type']) && $form['type']['#value'] .'_node_settings' == $form_id) {
    $type = $form['type']['#value'];
    $form['workflow']['event_nodeapi_'. $type] = array(
      '#type' => 'radios',
      '#title' => t('Show in event calendar'),
      '#default_value' => variable_get('event_nodeapi_'. $type, 'never'),
      '#options' => array('all' => t('All views'), 'solo' => t('Only in views for this type'), 'never' => t('Never')),
      '#description' => t('All views: This content type will be available for display on all calendar views, including with other events.<br />Only in views for this type: This content type will only appear in calendar views specific to this type and never with other events.<br />Never: This content type will not be associated with the events calendar.')
    );
  }
}

 /**
 * hook_nodeapi implementation
 *
 * @ingroup event_nodeapi
 */
function event_nodeapi(&$node, $op, $arg = 0) {
  if(variable_get('event_nodeapi_'. $node->type, 'never') != 'never') {
    switch ($op) {
      case 'form':
        global $user;
        $form['event_start'] = array(
          '#type' => 'fieldset',
          '#title' => t('Start'),
          '#description' => t('Start date.'),
          '#weight' => -15
          );
        $form['event_start']['date'] = event_form_date($node->event_start ? $node->event_start : _event_user_time(), 'start', $node->start_offset);

        $form['event_end'] = array(
          '#type' => 'fieldset',
          '#title' => t('End'),
          '#description' => t('End date.'),
          '#weight' => -15
          );
        $form['event_end']['date'] = event_form_date(($node->event_end ? $node->event_end : _event_user_time()), 'end', $node->end_offset);

        if (variable_get('event_timezone_input', 'site') == 'input') {
          $form['event_tz'] = array(
            '#type' => 'select',
            '#title' => t('Time zone'),
            '#default_value' => ($node->timezone ? $node->timezone : event_timezone_map(variable_get('date_default_timezone', 0))),
            '#options' => event_zonelist(),
            '#description' => t('Select the time zone this event occurs in.'),
            '#weight' => -14
            );
        }
        elseif (variable_get('configurable_timezones', 1) && $user->uid && strlen($user->timezone) && (variable_get('event_timezone_input', 'site') == 'user')) {
          $form['event_tz'] = array(
            '#type' => 'hidden',
            '#value' =>  event_timezone_map($user->timezone)
            );
        }
        else {
          $form['event_tz'] = array(
            '#type' => 'hidden',
            '#value' => event_timezone_map(variable_get('date_default_timezone', 0))
            );
        }
        return $form;

      case 'execute':
        event_validate_form_date($node, 'start');
        event_validate_form_date($node, 'end');
        if ($node->event_end < $node->event_start) {
          $node->event_end = $node->event_start;
        }
        switch (variable_get('event_timezone_display', 'event')) {
          case 'event' :
            $node->start_offset = event_get_offset($node->timezone, $node->event_start);
            $node->end_offset = event_get_offset($node->timezone, $node->event_end);
            break;
          case 'user' :
            global $user;
            $node->start_offset = $node->end_offset = $user->timezone;
            break;
          case 'site' :
            $node->start_offset = $node->end_offset = variable_get('date_default_timezone', 0);
            break;
        }
        $node->start_format = format_date($node->event_start, 'small', '', $node->start_offset);
        $node->end_format = format_date($node->event_end, 'small', '', $node->end_offset);
        break;

      case 'insert':
        $fields = array('nid', 'event_start', 'event_end');
        db_query('INSERT INTO {event} (nid, event_start, event_end, timezone) VALUES (%d, %d, %d, %d)', $node->nid, $node->event_start, $node->event_end, $node->timezone);
        event_set_range();
        break;

      case 'update':
        if (variable_get('event_nodeapi_'. $node->type, 'never') != 'never') {
          $fields = array('event_start', 'event_end');
          db_query('UPDATE {event} SET event_start = %d, event_end = %d, timezone = %d WHERE nid = %d', $node->event_start, $node->event_end, $node->timezone, $node->nid);
        }
        event_set_range();
        break;

      case 'delete':
        if (variable_get('event_nodeapi_'. $node->type, 'never') != 'never') {
          db_query('DELETE FROM {event} WHERE nid = %d', $node->nid);
        }
        event_set_range();
        break;

      case 'load':
        $object = db_fetch_object(db_query('SELECT event_start, event_end, timezone FROM {event} WHERE nid = %d', $node->nid));
        switch (variable_get('event_timezone_display', 'event')) {
          case 'event' :
            $start_offset = event_get_offset($object->timezone, $object->event_start);
            $end_offset = event_get_offset($object->timezone, $object->event_end);
            break;
          case 'user' :
            global $user;
            $start_offset = $end_offset = $user->timezone;
            break;
          case 'site' :
            $start_offset = $end_offset = variable_get('date_default_timezone', 0);
            break;
        }
        $ctype = module_invoke('flexinode', 'load_content_type', $node->ctype_id);

        return array('event_start' => $object->event_start,
                     'event_end' => $object->event_end,
                     'start_offset' => $start_offset,
                     'end_offset' => $end_offset,
                     'timezone' => $object->timezone,
                     'start_format' => format_date($object->event_start, 'small', '', $start_offset),
                     'end_format' => format_date($object->event_end, 'small', '', $end_offset),
                     'start_time_format' => format_date($object->event_start, 'custom', (variable_get('event_ampm', '0') ? 'g:i a' : 'H:i'), $start_offset),
                     'end_time_format' => format_date($object->event_end, 'custom', (variable_get('event_ampm', '0') ? 'g:i a' : 'H:i'), $end_offset),
                     'event_node_title' => ($ctype->name ? $ctype->name : $node->type));
        break;

      case 'view':
        if ($arg != 'ical item') {
          $node->body = theme('event_nodeapi', $node). $node->body;
          $node->teaser = theme('event_nodeapi', $node). $node->teaser;
        }
        break;

      case 'rss item':
        $node->body = theme('event_nodeapi', $node). $node->body;
        $node->teaser = theme('event_nodeapi', $node). $node->teaser;
        break;
    }
  }
}

function event_get_types($state = NULL) {
  static $types;
  if (!is_array($types)) {
    $types['all'] = array();
    $types['solo'] = array();
    $types['never'] = array();
    $result = db_query("SELECT * FROM {variable} WHERE name like 'event_nodeapi_%'");
    while ($type = db_fetch_object($result)) {
      $types[unserialize($type->value)][] = substr($type->name, 14);
    }
  }
  switch ($state) {
    case 'all':
        return $types['all'];
      break;
    case 'solo':
        return $types['solo'];
      break;
    case 'never':
        return $types['never'];
      break;
    default:
        return $types;
      break;
  }
}

function event_enabled_state($type) {
  $states = event_get_types();
  foreach ($states as $key => $state) {
    if (in_array($type, $state)) {
      return $key;
    }
  }
}

function event_is_enabled($type) {
  $states = event_get_types();
  return in_array($type, $states['all']);
}

function event_set_range() {
  $range = db_fetch_object(db_query('select MIN(e.event_start) AS event_start, MAX(e.event_end) AS event_end FROM {event} e'));
  variable_set('event_range_prev', $range->event_start);
  variable_set('event_range_next', $range->event_end);
}

function event_dst() {
  $timestamp = time();

  $zones = event_get_timezones();
  foreach($zones as $key => $zone) {
    if($zone['dst_region']) {
      $list[$zone['dst_region']][] = $zone['timezone'] .', '. (event_is_dst($zone['dst_region'], $timestamp) ? 'In DST' : 'Not in DST') . ': '. event_get_offset($key, $timestamp);
    }
    else {
      $list[$zone['dst_region']][] = $zone['timezone'] .': '. event_get_offset($key, $timestamp);
    }
  }
  $regions = event_get_dst_regions();
  foreach($list as $key => $region) {
    $output .= theme('box', $regions[$key], theme('item_list', $region));
  }

  drupal_set_title(t('Daylight Savings Regions | Current GMT: %date', array('%date' => gmdate('m-d-Y, H:i', $timestamp))));

  print theme('page', $output);
}

/**
 * Displays the help text for this module.
 *
 * @ingroup event_core
 * @param $section the page which is requesting help
 * @return the help text
 */
function event_help($section) {
  switch ($section) {
    case 'admin/modules#description':
        return t('Lets users make events and keep calendars.');
      break;
    case 'admin/help#event':
      return t("
      <h3>Background</h3>
      <p>This version of event module implements the drupal nodeapi system. There is no native event node type as in versions previous to 4.6, but instead node types can be 'event-enabled' through the %configure-link, the same way in which file attachments are assigned to node types with upload.module. This, combined with the dynamic content type functionality of %flexinode-link, make it possible to define almost any kind of calendar.</p>
      <p>Node types can be assigned to general calendar views, or only on their own calendar. For example, this makes it possible to have a general calendar which shows all 'meetups' and 'house parties' in the same place, but perhaps have a separate calendar for 'rallies' which only contains that type. The ability to filter calendar views by node type and taxonomy is also implemented, which allows many different possibilities for displaying content in the calendar system.</p>

      <h3><a id=\"url-format\"></a>Calendar display url formats</h3>
      The ability to filter calendar views by content type and taxonomy enables almost unlimited possibilities for displaying content with the calendar system. You can combine taxonomy and content type filters, the url construction scheme is currently as follows:
      <blockquote>
      ?q=event/\$year/\$month/\$day/\$view_type/\$content_type/\$taxonomy_terms/\$duration<br /><br />
      <strong>\$year:</strong> year value such as '2005'<br />
      <strong>\$month:</strong> month value with leading zeroes such as '02' for february<br />
      <strong>\$day:</strong> day value with leading zeroes such as '14'<br />
      <strong>\$view_type:</strong> type of calendar layout, values may include 'month', 'week', 'day', 'table', 'ical' for an ical export, and 'feed' for an rss feed.<br />
      <strong>\$content_type:</strong> list of node types, separated by '+'. Flexinode types only require the integer value of the type. For example, to view story nodes and type flexinode-1, you would use 'story+1'. The value 'all' will show all types.<br />
      <strong>\$taxonomy_terms:</strong> list of term ids, seperated by '+'. For example to view entries assigned to the taxonomy terms with ids 4 and 9 you would use '4+9'. The value 'all' will show all terms.<br />
      <strong>\$duration:</strong> number of days to display, currently only the table view obeys this setting. Eventually it may be used to specify additional duration parameters such as multiple weeks in the week view, or months in the month view.
      </blockquote>
      <p>There are url wrapper functions as well, which make it possible to easily create menu items to calendars by event type or taxonomy terms. This is necessary if you wish to create a link to a calendar but do not have a way to dynamically create the url based on the date, like in the menu or in a post.</p>
      <p>For links to a taxonomy filtered calendar the format is:
      <blockquote>
      ?q=event/term/\$taxonomy_terms<br /><br />
      <strong>\$taxonomy_terms:</strong> list of term ids, seperated by '+'. For example to view entries assigned to the taxonomy terms with ids 4 and 9 you would use '4+9'<br />
      </blockquote>
      For links to a content type filtered calendar the format is:
      <blockquote>
      ?q=event/type/\$content_type<br /><br />
      <strong>\$content_type:</strong> list of node types, separated by '+'. Flexinode types only require the integer value of the type. For example, to view story nodes and type flexinode-1, you would use 'story+1'
      </blockquote></p>",
      array('%configure-link' => l(t('content type management admin area'), 'admin/node/configure/types'), '%flexinode-link' => l(t('flexinode'), 'http://drupal.org/node/5737')));
      break;
    case 'event/dst':
        return t('This is a listing of all the event system\'s time zones, sorted by daylight savings time regions, and thier respective offsets from GMT in seconds. Time zones in the \'None\' region do not observe daylight savings time. If you believe there is an error, please first search for the locale on %timeanddate and confirm it. If there is indeed an error please submit a %bugreport on drupal.org so we can fix it.', array('%timeanddate' => l('http://timeanddate.com/worldclock/search.html', 'http://timeanddate.com/worldclock/search.html'), '%bugreport' => l('bug report', 'http://drupal.org/node/add/project_issue/event')));
      break;
  }
}

?>
